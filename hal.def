               //*************************************** 
               //***     HAL DEFINITIONS FILE       ****
               //***************************************

// Each category definition contains the name and description of
// checks (or other categories) that make up the body of the category.
//
// Optionally, the category may contain keywords 'synth_only', 'default_on'
// or 'default_off' after the description.  These keywords, if present,
// control which categories are checked by default (default_off/default_on)
// and whether or not the category is affected by the synthesis_off/on
// pragmas in the HDL source (synth_only).



//***************************************************************************
//** Following is the description of the default category hierarchy in HAL **
//***************************************************************************

// Only the categories that have or can have language specific checks are 
// further classified into sub-categories on the basis of language. The
// ones that are not classified, by default have checks which are applicable
// to both Verilog and VHDL designs. 

category ALL "This category consists of all the categories in HAL" default_on
{
 ALL_BEHAVIORAL //Category of all the BeThe new starting pay for UTAs is $11/hr. Returning UTAs (assuming acceptable performance) will receive $12/hr this fall. havioral checks
 ALL_RTL        //Category of all the RTL checks 
 ALL_NETLIST    //Category of all the Netlist checks
 ALL_TOOL       //Category of all the Tool warnings/errors 
 ALL_E          //Category of all the e Linting checks
}


category ALL_BEHAVIORAL "Category of all the Behavioral level checks" default_off
{
 BEH_CODINGSTYLE_VHDL  //Category of all the VHDL only behavioral coding style checks
}


category ALL_RTL "Category of all the RTL level checks" default_on
{
 RTL_NAMING        //Category of all the RTL Naming checks
 RTL_FILEFORMAT    //Category of all the RTL File format checks
 RTL_CODECOMMENT   //Category of all the RTL Code comment checks
 RTL_CODINGSTYLE   //Category of all the RTL coding style checks
 RTL_SIMSYNTH      //Category of all the checks to prevent Simulation Synthesis mismatch 
 RTL_SYNTH         //Category of all the synthesizability checks 
 RTL_SIMRACE       //Category of all the simulation race condition checks
 DFT               //Category of all Design For Testability (DFT) checks
 FSM               //Category of all the FSM coding style checks 
 STRUCTURAL        //Category of all the structural checks
 CLOCKDOMAIN       //Category of all the clock domain checks
 RMM               //Category of all the checks complying to RMM guidelines
 LOW_POWER         //Category of all the low power checks
 RTL_SIMPERF       //Category of all the performance checks
}


category ALL_NETLIST "Category of all the Netlist level checks" default_off
{
 DFT             //Category of all Design For Testability (DFT) checks
 STRUCTURAL      //Category of all the structural checks
 CLOCKDOMAIN     //Category of all the clock domain checks
 SCANCHAIN       //Category of all the scan chain checks
}



category RTL_NAMING "Category of all the RTL Naming checks" default_off
{
 RTL_NAMING_VERILOG      //Category of all the Verilog only Naming checks
 RTL_NAMING_VHDL         //Category of all the VHDL only Naming checks
 RTL_NAMING_MIXED        //Category of all the Naming checks for Verilog and VHDL
 RTL_NAMING_ASSERTIONS   //Category of all the Naming checks for SystemVerilog Assertions
}


category RTL_FILEFORMAT "Category of all the RTL File format checks" default_on
{
 RTL_FILEFORMAT_VERILOG //Category of all the Verilog only File format checks
 //mcj RTL_FILEFORMAT_VHDL    //Category of all the VHDL only File format checks
 //mcj RTL_FILEFORMAT_MIXED   //Category of all the File format checks for Verilog & VHDL
}

category RTL_CODECOMMENT "Category of all the RTL Code comment checks" default_off
{
 RTL_CODECOMMENT_VERILOG //Category of all the Verilog only Code comment checks
 RTL_CODECOMMENT_MIXED   //Category of all the Code comment checks for Verilog & VHDL
}


category RTL_CODINGSTYLE "Category of all the RTL coding style checks" default_on
{
 RTL_CODINGSTYLE_VERILOG        //Category of all the Verilog only Coding style checks
 //mcj RTL_CODINGSTYLE_VHDL           //Category of all the VHDL only Coding style checks
 //mcj RTL_CODINGSTYLE_MIXED          //Category of all the Coding style checks for Verilog & VHDL
 //mcj RTL_CODINGSTYLE_ASSERTIONS     //Category of all the Coding style checks for Assertions
}


category RTL_SIMRACE "Category of all the simulation race condition checks" default_on
{
 RTL_SIMRACE_VERILOG //Category of all the Verilog only race condition checks
 // Simulation race conditions do not exist in VHDL designs
}


category RTL_SIMSYNTH "Category of pre and post-synthesis simulation mismatch checks" default_on 
{
 RTL_SIMSYNTH_VERILOG //Verilog only pre and post-synthesis simulation mismatch checks
 RTL_SIMSYNTH_MIXED   //Verilog and VHDL pre and post-synthesis simulation mismatch checks
}


category RTL_SYNTH "Category of all the synthesizability checks" default_on //mcj synth_only
{
 RTL_SYNTH_VERILOG  //Category of all the Verilog only synthesizability checks
 //mcj RTL_SYNTH_VHDL     //Category of all the VHDL only synthesizability checks
 //mcj RTL_SYNTH_MIXED    //Category of all the synthesizability checks for Verilog and VHDL
}


//***************************************************************************
//** Following is the detail of the checks present in each category in HAL **
//***************************************************************************

category BEH_CODINGSTYLE_VHDL "Behavioral level coding style checks" default_off
{
  //* Important - The checks in this category are sensitive to the architecture name
  //* as defined by the  parameter "BEH_ARCHNM"

  WNBFLK {level=1}  // "Port '%s' should not be of mode buffer or linkage"
  SYNCSL {level=1}  // "The sensitivity list of a sequential process does not contain an asynchronous reset"
  BEHINI {level=2}  // "A behavioral variable/signal '%s' is not initialized in its declaration"
  SUBTNM {level=2} // "Subtype name '%s' does not contain the type name '%s'"
  ENTDCL {level=3}  // "A VHDL entity should only consist of generic and port interface lists"
  UNITNM {level=3}  // "VHDL design-unit name '%s' is missing on the end line"
  SUBPNM {level=3}  // "VHDL %s name '%s' is missing on the end line"
  NOLABL {level=3}  // "Process label '%s' is missing as a closing label"
  MAXPRT {level=3}  // "Entity '%s' must not have more than %d ports"
  PDFPKG {level=3}  // "The standard/IEEE package '%s' should not be used"
  MLITNU {level=3}  // "The enumeration type '%s' should not contain more than %d literals"
  DESULN {level=3}  // "The length of design-unit '%s' should not exceed %d lines"
  FENAME {level=3}  // "Identifier '%s' updated on negative edge of clock should have '_f' as suffix"
  USRATN {level=3}  // "User-defined attribute '%s' is being used in architecture '%s'"
}


category RTL_NAMING_VERILOG "Verilog only Naming checks" default_off
{
  MODLNM {level=4} // "Module name '%s' does not follow the naming convention"
  SVIFNM {level=4} // "SystemVerilog interface name '%s' does not follow the naming convention"
  INSTNM {level=4} // "Instance name '%s' does not follow the naming convention"
  BLKLNM {level=4} // "Begin/end block name '%s' does not follow the naming convention"
  FUNCNM {level=4} // "Function name '%s' does not follow the naming convention"
  TASKNM {level=4} // "Task name '%s' does not follow the naming convention"
  PARMNM {level=4} // "Parameter name '%s' does not follow the naming convention"
  INTGNM {level=4} // "Integer variable name '%s' does not follow the naming convention"
  REALNM {level=4} // "Real variable name '%s' does not follow the naming convention"
  MEMRNM {level=4} // "Memory name '%s' does not follow the naming convention"
  WIRENM {level=4} // "Wire name '%s' does not follow the naming convention"
  REGRNM {level=4} // "Register name '%s' does not follow the naming convention"
  FFNAME {level=4} // "The flip-flop name '%s' does not follow the naming convention. The name should end with 'pattern'"
  VLFLNM {level=4} // "File name '%s' does not follow the verilog naming convention%s"
  MACRNM {level=2}  // "Macro name '%s' does not follow the naming convention"
 }

category RTL_NAMING_ASSERTIONS "SystemVerilog Assertion only Naming checks" default_off
{
  LOCVNM  {level=4} // "Local variable '%s' in '%s' does not follow the recommended naming convention"
  ASTMNM  {level=4} // "Assert statement '%s' does not follow the recommended naming convention"
  COVRNM  {level=4} // "Cover statement '%s' does not follow the recommended naming convention"
  ASUMNM  {level=4} // "Assume statement '%s' does not follow the recommended naming convention"
  PROPNM  {level=4} // "Property '%s' does not follow the recommended naming convention"
  SEQNNM  {level=4} // "Sequence '%s' does not follow the recommended naming convention"
}

category RTL_NAMING_VHDL "VHDL only Naming checks" default_off
{
  ARCHNM {level=4}  // "Architecture name '%s' does not follow the naming convention"
  ENTYNM {level=4}  // "Entity name '%s' does not follow the naming convention"
  PCKGNM {level=4}  // "Package name '%s' does not follow the naming convention"
  CMPPKG {level=4}  // "Package name %s does not follow the recommended naming convention"
  SUBRNM {level=4}  // "Subprogram name '%s' does not follow the naming convention"
  ACCSNM {level=4}  // "Access-type name '%s' does not follow the naming convention"
  CNSTNM {level=4}  // "Constant name '%s' does not follow the naming convention"
  FILENM {level=4}  // "File name '%s' does not follow the naming convention"
  LIBRNM {level=4}  // "Library name '%s' does not follow the naming convention"
  SIGLNM {level=4}  // "Signal name '%s' does not follow the naming convention"
  VARLNM {level=4}  // "Variable name '%s' does not follow the naming convention"
  CONFNM {level=4}  // "Configuration name '%s' does not follow the naming convention"
  CONFIL {level=4}  // "Configuration file name '%s' does not follow the naming convention"
}


category RTL_NAMING_MIXED "Naming checks for Verilog and VHDL" default_off
{
  NLIBNM {level=2}  // "Name '%s' used in the technology library is same as a module/instance name"
  PORTNM {level=4}  // "Port name '%s' does not follow the naming convention"
  TBCHNM {level=4}  // "File name '%s' does not follow the recommended testbench naming convention%s"
  OUTPNM {level=4}  // "Output port name '%s' does not follow the naming convention"
  INPTNM {level=4}  // "Input port name '%s' does not follow the naming convention"
  IOPTNM {level=4}  // "Inout port name '%s' does not follow the naming convention"
  CLKSNM {level=4}  // "Clock signal name '%s' does not follow the naming convention"
  RSTNAM {level=4}  // "Reset signal name '%s' does not follow the recommended naming convention"
  //mcj DIFCLK {level=4}  // "Clock '%s' is being renamed to '%s'"
  DIFRST {level=4}  // "Set/Reset '%s' is being renamed to '%s'"
  RENAME {level=4} // "Signal '%s' renamed as '%s'"
  UCOPNM {level=4} // "Unconnected output signal name '%s' does not follow the recommended naming convention"
  NTACHR {level=4} // "Identifier '%s' contains characters that are not allowed"
  FCNLTR {level=4} // "First character of identifier '%s' is not a letter"
  ESCNTA {level=4} // "Identifier '%s' contains escaped names, which should not be used"
  RGOPNM {level=4} // "Output register name '%s' does not follow the recommended naming convention"
  TESTNM {level=4} // "Test mode signal '%s' does not follow the recommended naming convention"
  HIMPNM {level=4} // "High impedance signal '%s' does not follow the recommended naming convention"
  STMCNM {level=4} // "State machine's state '%s' does not follow the recommended naming convention"
  LTCHNM {level=4} // "Latch '%s' does not follow the recommended naming convention" 
  MULSNO {level=4} // "Signal name '%s' does not follow the multiple suffix naming order" 
  DIFSIG {level=4} // "Actual port name '%s' of instance '%s' does not follow the recommended naming convention"
}

//' quote inserted just because unbalanced quote was messing up colors in gvim



category RTL_FILEFORMAT_VERILOG "Verilog only File format checks" default_on
{
  VERREP {level=3}  // "Repeated usage of identifier or label name '%s'"
  KEYWOD {level=3}  // "Verilog reserved word '%s' used as an identifier or label"
  MULTMF {level=3}  // "More than one module definition in file '%s'"
  PRTODR {level=4}  // "Port declaration '%s' does not follow the port layout order or/and does not match the port list"
  PRTLYO {level=4}  // "Ports declared in module '%s' do not follow the port layout order"
}


category RTL_FILEFORMAT_VHDL "VHDL only File format checks" default_off
{
  CASMIS {level=2}  // "VHDL object '%s' has case mismatch between instantiation and declaration"
  COMDIF {level=2}  // "VHDL object '%s' has mismatch between component and its entity declaration"
  VHDREP {level=3}  // "Repeated usage of identifier or label name '%s'"
  STYSUL {level=3}  // "Type std_ulogic used for identifier '%s'. Use std_logic to avoid portability issues"
  STYSUV {level=3}  // "Type std_ulogic vector used for identifier '%s'. Use std_logic_vector to avoid portability issues"
  STYBIT {level=3}  // "Type bit used for identifier '%s'. Use std_logic to avoid portability issues"
  STYBTV {level=3}  // "Type bit_vector used for identifier '%s'. Use std_logic_vector to avoid portability issues"
  GENUSD {level=3}  // "Generate statement used. This will create portability issues"
  STYBLK {level=3}  // "Block statement used. This will create portability issues"
  MXPROC {level=3}  // "The architecture '%s' contains more than %d process statements" 
  ONELIB {level=3}  // "Single library declaration clause used to declare multiple library names"
  ARCHID {level=3}  // "Architecture name '%s' does not follow recommended naming convention"
  INPPRT {level=4}  // "Input port '%s' does not follow the layout convention"
  CLKPRT {level=4}  // "Clock port '%s' does not follow the layout convention"
  RSTPRT {level=4}  // "Reset port '%s' does not follow the layout convention"
  INOPRT {level=4} // "Inout/Buffer port '%s' does not follow the layout convention"
}


category RTL_FILEFORMAT_MIXED " File format checks for Verilog and VHDL" default_off
{
  VERCAS {level=2}  // "Identifier, label, instance, or module name '%s' reused with just case difference" 
  DIRRNG {level=2}  // "Inconsistent ordering of bits in range declarations"
  KYEDIF {off}  // "EDIF reserved word '%s' used as an identifier or label"
  NEEDIO {off}  // "Top-level module '%s' has no inputs/outputs/inouts"
  IDLENG {off}  // "Identifier name '%s' is not of appropriate length (%d to %d characters)"
  ALOWNM {off}  // "Identifier '%s' does not follow the recommended naming convention"
  KVHWOD {level=3}  // "Verilog reserved word '%s' used as an identifier or label"  
  STYVAL {level=3}  // "Numeric value '%d' used for identifier '%s'. Use constants to avoid portability issues"
  SUBPLN {off}  // "The length of subprogram '%s' should not exceed %d lines"
  SYSVKW {level=3}  // "SystemVerilog reserved word '%s' used as an identifier or label"  
  AMSKWD {off}  // "AMS reserved word '%s' used as an identifier or label"  
  UPCSFN {off}  // "Uppercase characters used in file name or path: %s"
  CTLCHR {level=4}  // "HDL source line contains one or more control characters"
  UPCLBL {off}  // "Label '%s' should be written in uppercase"
  DIFFMN {level=4}  // "%s name '%s' differs from file name '%s'"
  NOBLKN {off}  // "Each block should be labeled with a meaningful name"
  //mcj SEPLIN {level=4}  // "Use a separate line for each HDL statement"
  LCVARN {off}  // "%s name '%s' uses uppercase characters" 
  UCCONN {level=4}  // "Lowercase characters used for identifier '%s'. Use uppercase characters for names of constants and user-defined types"
  NOINSN {off}  // "Each module/gate/primitive instance should be labeled with a meaningful name"
  FILSUF {level=4}  // "The file name '%s' is missing a valid HDL file name extension"
  DECLIN {level=4}  // "Use a separate line for each HDL declaration"
  MAXLEN {level=4}  // "The HDL source line is %d characters long, which exceeds the recommended length of %d characters"
  SIGLEN {off}  // "Signal name '%s' is not of appropriate length (%d to %d characters)"
 
}

category RTL_CODECOMMENT_VERILOG "Verilog only Code comment checks" default_off
{
  COMSTY {level=4} // "Do not use '%s' comment style in code"
  COMINS {level=4} // "Instantiated cells should have a comment on the same or preceding line"
  COMDIR {level=4} // "Compiler directive '%s' should have a comment on the same or preceding line"
  COMEND {level=4} // "Verilog end/endcase statement should have a comment on the same line"
  COMLTH {level=4} // "Latch declarations should have a comment on the same or preceding line"
}

category RTL_CODECOMMENT_MIXED "Code comment checks for Verilog and VHDL" default_off
{
  COMBLK {level=4} // "Always/process block should have a comment on the same or preceding line"
  COMIOP {level=4} // "Port declarations should have a comment on the same or preceding line"
  COMDEC {level=4} // "Net/signal declarations should have a comment on the same or preceding line"
  COMGTD {level=4} // "Gated clocks should have a comment on the same or preceding line"
  FHDRFT {level=4} // "File header format does not follow the template"
  SHDRFT {level=4} // "Sub header format for %s does not follow the template"
}


category RTL_CODINGSTYLE_VERILOG "Verilog only coding style checks" default_on
{
  WRGSNS {level=0}  // "In module %s, Posedge and Negedge of the same signal present in the sensitivity list of an always block"
  NEGIDX {level=1} // "Negative or enumeration value used as an array index at '%s'"
  NBCOMB {level=1}  // "Non-blocking assignment encountered in a combinational block"
  IFDDEF {level=1}  // "Macro '%s' is defined using `define statement in the same verilog file"
  DBCASX {level=1}  // "Dont care value specified for discontinuous bits in casex item '%s'"
  BLKSQB {level=1}  // "Blocking assignment encountered in a sequential block"
  //mcj CDEFCV {level=1}  // "The case items of the case statement in module/design-unit %s cover all the numerical values of the case expression. The default clause is not required"
  BLNBLK {level=1}  // "Signal '%s' is assigned via both blocking and non-blocking assignments"
  EVUNTR {level=1}  // "Event variable '%s' is never triggered"
  LOGAND {level=1}  // "Bit-wise AND in a conditional expression. Logical AND may have been intended"
  LOGORP {level=1}  // "Bit-wise OR in a conditional expression. Logical OR may have been intended"
  LOGNEG {level=1}  // "Bit-wise negation in a conditional expression. Logical NOT may have been intended"
  MULOPR {level=1}  // "Logical %s operator applied to multi-bit operand%s in module/design-unit %s"
  INCMPC {level=1}  // "Not all cases are covered in the parallel case (%d of possible %d covered)"
  CASEZX {level=1}  // "Case item expression contains 'x' for a casez statement (useful only in casex statements)"
  OBMEMI {level=1}  // "Memory word '%s[%s]' has an index of size %d, which may reference a memory word, which is outside the defined range of the memory (%d words) in module/design-unit %s"
  DIFRNG {level=1}  // "Port '%s' with range (%d to %d) is re-declared with a different range (%d to %d)"
  //mcj CONSLC {level=1}  // "Module '%s' contains a loop with a constant conditional expression"
  OOMCAL {level=1}  // "Use of an out-of-module task call to %s"
  INPOUT {level=1}  // "Primary input port %s of module %s may be driven inside the module"
  SIZMIS {level=1}  // "Port '%s' has size mismatch between module instantiation and declaration"
  //mcj PRTSYN {level=1}  // "Port '%s' is declared using a mix of VLOG95 and VLOG2001 declaration styles"
  UEASPD {level=1}  // "Unequal length operands in assignment in module/design-unit '%s'. Length of RHS is less than LHS"
  UEASTR {level=1}  // "Unequal length operands in assignment in module/design-unit '%s'. Length of RHS is greater than LHS"
  OPRNUM {level=1}  // "Expression uses '%d' operators, which exceeds the recommended limit of operators"
  CONDSZ {level=1}  // "Expression in condition does not result in a single bit value in module/design-unit %s"
  OPLVNC {level=1}  // "'%s' operation between loop variable '%s' and non constant value '%s'"
  PRMVAL {level=1}  // "Bit width not specified for parameter '%s'"
  CSTBWD {level=1}  // "Bit width not specified for constant '%s'"
  CSWDXZ {level=1}  // "Bit width not specified for constant '%s' with 'x/z' as msb"
  PRMBSE {level=1}  // "Base not specified for parameter '%s'"
  MULCAS {level=1}  // "Overlapping case item %s in module/design-unit %s"
  PTYSIG {level=1}  // "Signed %s '%s'  has separate port and type declarations"
  FNAVPC {level=1} // "Function '%s' is not assigned a value in some of the branches of conditional statement(s)"
  NEGCLK {level=1} // "Clock signal '%s' of '%s' is derived from an inverter"
  DTEVST {level=1}  // "Edge specified for data event '%s' in system task '%s'"
  NBFUNC {level=2}  // "Non-blocking assignment encountered in function '%s'"
  BADSYS {level=2}  // "System task '%s' in module '%s' is ignored" 
  //mcj RTLNOG {level=2}  // "Gate instances are not expected in an RTL design"
  //mcj RTLNOP {level=2}  // "Primitive instances are not expected in an RTL design"
  RTLINI {level=2}  // "A variable/signal '%s' in an RTL description is initialized in its declaration"
  PLIFTN {level=2}  // "PLI 1.0 function %s in module '%s' is ignored"
  EMPSTM {level=2}  // "Module '%s' contains an empty statement"
  EMPBLK {level=2}  // "Module '%s' contains an empty begin/end block"
  IGNSTR {level=2}  // "Strength values are ignored"
  LIBIMP {level=2}  // "'%s' is supported only in library cells"
  //mcj NOSPEC {level=2}  // "%s mentioned in the specify block of module %s is ignored. Use -CONNECT_SPECIFY_BLOCK to preserve connections in the design"
  INIMEM {level=2}  // "Initialization of memory '%s' in module '%s' is ignored"
  NOGATE {level=2} // "Module %s contains unsupported gate type %s" 
  NOSWTC {level=2}  // "Module %s contains non-synthesizable switch type %s"
  NOWIRE {level=2}  // "Module %s contains node %s of unsupported trireg type"
  FSETGV {level=2}  // "Function '%s' in module '%s' assigns a value to global variable '%s'"
  FTNNAS {level=2}  // "Last statement in function '%s' in module '%s' does not assign any value to the function"
  FUSEGV {level=2}  // "Function '%s' in module '%s' uses global variable '%s'"
  //mcj TSETGV {level=2}  // "Task '%s' in module '%s' assigns a value to global variable '%s'"
  //mcj TUSEGV {level=2}  // "Task '%s' in module '%s' uses global variable '%s'"
  USEPAR {level=2}  // "Parameter '%s' is unused"
  USEENM {level=2}  // "Enum variable '%s' defined in %s '%s' is unused"
  USEWIR {level=2}  // "Wire '%s' defined in module '%s' is unused"
  USEREG {level=2}  // "Local register variable '%s' defined in %s '%s' is unused"
  USETSK {level=2}  // "Task '%s' is unused"
  CONSTD {level=2}  // "Delay is not a constant expression"
  DLNBLK {level=2}  // "Delay in non-blocking assignment; delay will be ignored"
  NULPRT {level=2}  // "Module '%s' has null formal port(s)"
  UASWIR {level=2}  // "Wire '%s' defined in module '%s' is unassigned, but drives at least an object"
  UASREG {level=2}  // "Local register variable '%s' is unassigned, but is read at least once in %s %s"
  UASINT {level=2}  // "Integer variable '%s' is unassigned, but is read at least once in %s %s"
  URDWIR {level=2}  // "Wire '%s' defined in module '%s' does not drive any object, but is assigned at least once"
  URDREG {level=2}  // "Local register variable '%s' is not read, but is assigned at least once in %s '%s'"
  URDINT {level=2}  // "integer variable '%s' is not read, but is assigned at least once in %s '%s'"
  URAWIR {level=2}  // "Wire '%s' defined in module '%s' is unused (neither read nor assigned)"
  URAINT {level=2}  // "integer '%s' defined in module '%s' is unused (neither read nor assigned)"
  URAREG {level=2}  // "Local register variable '%s' defined in %s '%s' is unused (neither read nor assigned)"
  IMPNET {level=2}  // "Net '%s' has an implicit declaration of type '%s'"
  IMPDTC {level=2}  //  "Expression '%s' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit %s"
  IMPTYP {level=2}  //  "Expression '%s' implicitly converted to type '%s' from type '%s'"
  IPUFSE {level=2}  //  "Expression '%s' implicitly converted to type 'signed' from type 'unsigned' in module/design-unit %s"
  IPSFOU {level=2}  //  "Signal/Constant '%s' implicitly converted to type 'signed' from type 'unsigned'"
  MXUANS {level=2}  //  "Expression '%s' in module/design-unit %s has both signed and unsigned variables/constants"
  RDBFAS {level=2}  // "Register '%s', assigned using blocking assignment, is being read before getting assigned"
  REVROP {level=2}  // "Register '%s' is being read/assigned outside the process in which it was assigned using a blocking assignment"
  PRMNAM {level=2}  // "Passing of parameters to instance '%s' of module '%s' should be done by name rather than by position"
  EXPIPC {level=2}  // "Formal port %s of instance '%s' is connected to an expression"
  FORINT {level=2}  // "Variable '%s' is not initialized before being incremented/decremented in the for loop"
  //mcj FINBLK {level=2}  // "The final block of module '%s' does not contain any display statement"
  STRREL {level=2}  // "String %s is used in the relational operation '%s' in module/design-unit %s"
  PRMSZM {level=2}  // "Parameter '%s' has a size mismatch between module instantiation and declaration"
  //mcj FCWDEF {level=2}  // "Redundant case expression -- full_case has a default case"
  SGNUSG {level=2}  // "Negative value '%s' assigned to an unsigned variable '%s' in module/design-unit %s"
  OVRDRT {level=2}  // "The return statement will override the value assigned to the function name"
  //mcj CAFDEF {level=2} // "'default' is not the last item of case statement"
  BITUNS {level=2} // "Not all bits of constant '%s' are explicitly specified"
  BSINTT {level=2}  // "Bit/part select of %s variable '%s' encountered"
  REDOPR {level=2} // "Reduction '%s' operation performed on '%d' bits expression '%s'"
  USEMAC {level=2} // "Macro '%s' is unused
  DUPMCR {level=2}  // "Macro '%s' is defined at multiple places with same definition"
  //mcj MLPSGS {level=2}  // "Multiple %s signals used in flip-flop '%s'"
  NSTIFD {level=2}  // "The ifdef directive has exceeded three levels of nesting"
  //mcj CDWARN {level=2}  // "The compiler directive '%s' is used in the RTL."
  //mcj CDNOTE {level=2}  // "The compiler directive '%s' is used in the RTL."
  SNOROP {level=2}  // "Operator other than 'or' or ',' used in sensitivity list"
  IGSPEC {level=2}  // "%s mentioned in the specify block of module %s is ignored"
  INDXOP {level=2}  // "A/An '%s' operator used in the index of the array '%s'"
  LMULOP {level=2}  // "The result of the multiplication operation exceeds '%d' bits in module/design-unit %s"
  TMSMIS {level=2}  // "Timescale is missing for the module '%s'"
  LRGOPR {level=2}  // "Arithmetic or relational operation performed on large operands in module/design-unit %s"
  PIMBIT {level=2}  // "Primitive input port (port index : %d ) is connected to signal/expression with multiple bits. Reduction OR logic is being applied"
  IFMULT {level=2}  // "Conditional expression '%s' completely overlaps one or more branches of the 'if-else' block in module/design-unit %s"
  CSTEXP {level=2}  // "A variable/Expression is used for items of a case statement"
  DNSTIF {level=2}  // "Deep nesting of If/else-if statements results in the synthesis of complicated logic by synthesis tool"
  RPTVAR {level=2} // "Variable '%s' is used repetitively in the statement inside loop body"
  IFESLV {level=2}  // "If/If-else statement nested to %d levels"
  CSTLOA {level=2}  // "Case selector '%s' is an expression"
  LOPIDX {level=2}  // "Loop variable '%s' of the 'for' loop is not of recommended data type(s) (%s)"
  CONSBS {level=2} // "Base ('d, 'b, 'h, 'o) not specified for %s %s in module/design-unit %s"
  IFSMCD {level=2} // "Condition '%s' is present in all the branches of if/if-else statement"
  INDNES {level=2} // "Two or more variables are used in nested index part select"
  MULTMS {level=2} // "Multiple timescales exist in the design"
  HLBINP {level=2} // "Input port '%s' of physical block '%s' is connected to 2 or more flip-flops or latches."
  NMODPT {level=2} // "The interface does not contain a modport"
  TDOPKG {level=2} // "Typedef definition '%s' is not declared in any of the SystemVerilog packages, it is declared in scope '%s'."
  VARUAW {level=2} // "Output port '%s' is defined as '%s', but is used as wire"
  PKGICU {level=2} // "Package '%s' is imported into the compilation unit scope"
  NBGEND {level=2} // "Missing begin/end statement in the '%s' block"
  ENUMAW {level=2} // "Incorrect data type assigned to the enum variable in packed structures"
  RDNTCX {level=3} // "Casex usage is redundant as none of the case item expression contains 'x', 'z', or '?' in module/design-unit %s"
  RDNTCZ {level=3} // "Casez usage is redundant as none of the case item expression contains 'z' or '?' in module/design-unit %s"
  //mcj NOINCD {level=3}  // "Compiler directive `include should not be used" 
  RDOPND {level=3}  // "Expression contains redundant %s"
  BVDDAB {level=3}  // "Bits of variable '%s' are driven in different %s always blocks"
  NCASEX {level=3}  // "'casex' statement used in module '%s'"
  NFCASE {level=3}  // "'full_case' synthesis directive used in module '%s'"
  //mcj NOUNDF {level=3}  // "Macro defined using `define statement is not undefined using `undef statement in module '%s'"  
  //mcj NODEFD {level=3}  // "Compiler directive `define should not be used"
  NETDCL {level=3}  // "<Signal/Constant> '%s' is not declared prior to non-declarative statement(s) or does not follow the recommended declaration sequence"
  ENMNFU {level=2}  // "The enumeration type '%s' is not fully used"
  NAUTOF {level=2}  // "The SystemVerilog function '%s' without the automatic keyword may be unsynthesizable"
  UDTRWI {level=2}  // "Data type '%s', other than reg, wire and integer, is used for '%s'"
  CLKFST {level=2}  // "For flip-flop, the clock '%s' should be the first element in the sensitivity list"
  BUSREV {level=3}  // "Formal port '%s[%d:%d]' is connected in opposite order with the actual port(s)."
  MLTEQU {level=3}  // "An expression in the design contains more than one successive equal/non-equal operator with two constants"
  //mcj INCLDR {level=4}  // "Absolute or relative path specified with the `include compiler directive"
  OLDALW {level=2}  // "Old coding style for always block found in module '%s', use '%s' instead"
  FTNEST {level=1} // "Function/Task '%s' has been nested"
  TPRUSD {level=2}  // "Tool specific '%s' pragma is used in RTL"
  NSCOLL {level=2}  // "Name space collision detected between objects imported from packages in the %s '%s'"
}


category RTL_CODINGSTYLE_VHDL "VHDL only coding style checks" default_off
{
  //* Important - The checks in this category are sensitive to the architecture name
  //* as defined by the  parameter "RTL_ARCHNM" 

  NEGRNG {level=1}  // "Index range of integer signal '%s' is '%d'"
  ENBFLK {level=1}  // "Port '%s' should not be of mode linkage"
  WNBBUF {level=1}  // "Port '%s' should not be of mode buffer"
  SYNCSL {level=1}  // "The sensitivity list of a sequential process does not contain an asynchronous reset"
  MLTCLK {level=1}  // "The sequential process contains more than one clock signal"
  CLKEDG {level=1}  // "Both edges of clock signal '%s' are used in a sequential process"
  GATCLK {level=1}  // "Gated clock signal '%s' is not properly formed/used"
  BADCON {level=1}  // "Bad VHDL construct '%s' is being used"
  FTNRET {level=1}  // "Function '%s' declared in architecture '%s' does not return a value"
  INVBAS {level=1}  // "Invalid base (%d) used in VHDL based literal"
  CDNWOT {level=1}  // "Case statement without 'when others' clause"
  ENTDCL {level=2}  // "A VHDL entity should only consist of generic and port interface lists"
  RTLINI {level=2}  // "A variable/signal '%s' in an RTL description is initialized in its declaration"
  GENTYP {level=2}  // "The generic '%s' is not of an authorized type"
  PRTTYP {level=2}  // "Port '%s' is not of an authorized type (std_logic, std_logic_vector, signed, unsigned)"
  SEQVAS {level=2}  // "VHDL variable '%s' is used to register data"
  UNITNM {level=2}  // "VHDL design-unit name '%s' is missing on end line"
  SUBPNM {level=2}  // "VHDL %s name '%s' is missing on end line"
  NOLABL {level=2}  // "Process label '%s' is missing as a closing label"
  NOALIA {level=2}  // "Aliases should not be used"
  SPSIGA {level=2}  // "Subprogram assigns a value to signal '%s'"
  SUBTNM {level=2}  // "Subtype name '%s' does not contain the type name '%s'"
  NRTLWT {level=2}  // "Sensitivity lists should be used instead of wait statements"
  CECONC {level=2}  // "Concatenation operation used in conditional expression"
  FENAME {level=2}  // "Identifier '%s' updated on negative edge of clock should have _f suffix"
  GLBSIG {level=2}  // "Global signal '%s' is being used in architecture '%s'"
  USRATW {level=2}  // "User-defined attribute '%s' is being used in architecture '%s'"
  ONELIB {level=2}  // "Single library declaration clause used to declare multiple library names"
  PROSIG {level=2}  // "Signal '%s' defined in architecture '%s' is used inside only one process. Use variable instead"
  PRTMOD {level=2}  // "Port mode mismatch in '%s' component declaration for port '%s'. Declaration is of mode %s, entity port declaration is of mode %s"
  PUSEGV {level=2}  // "Procedure '%s' in design-unit '%s' uses global variable '%s'"
  WRKLIB {level=2}  // "Library '%s' should not be referenced in the design"
  CALABL {level=2}  // "Concurrent signal assignment used to express behavior requires a label"
  FTNPMC {level=2}  // "Parameter '%s' of function '%s' has missing/incorrect mode and/or object class"
  PROPMC {level=2}  // "Parameter '%s' of procedure '%s' has missing/incorrect mode and/or object class"
  ENTPMC {level=2}  // "No mode specified for port '%s' in entity declaration"
  COMPMC {level=2}  // "No mode specified for port '%s' in component declaration"
  LPEXIT {level=2}  // "Loop contains an exit or next statement"
  RECTYP {level=2}  // "Record type '%s' should not be used"
  USELIB {level=2}  // "Library '%s' is declared, but no object is used from it"
  LINPRT {level=2}  // "Port '%s' of mode linkage does not form part of the layout convention"
  GLBRES {level=2}  // "Global signal '%s' is of resolved type"
  IDXMIS {level=2}  // "Port '%s' has index bounds mismatch between component instantiation '%s' and entity declaration '%s'"
  UASVAR {level=2}  // "Variable '%s' is unassigned, but is read at least once in %s '%s'"
  URAVAR {level=2}  // "Variable '%s' defined in %s '%s' is unused (neither read nor assigned)"
  URDVAR {level=2}  // "Variable '%s' is not read, but assigned at least once in %s '%s'"
  UASSIG {level=2}  // "Signal '%s' is unassigned, but is read at least once in %s '%s'"
  URASIG {level=2}  // "Signal '%s' defined in %s '%s' is unused (neither read nor assigned)"
  URDSIG {level=2}  // "Signal '%s' is not read, but assigned at least once in %s '%s'"
  USCNST {level=2}  // "Constant '%s' defined in %s is unused"
  FILTXT {level=2}  // "File specified with file variable '%s' is not of type TEXT"
  ABSPAT {level=2}  // "Absolute path specified for file variable '%s'"
  PWTHWT {level=2}  // "Process block with no sensitivity list is without a wait statement"
  MAXPRT {level=3}  // "Entity '%s' must not have more than %d ports"
  MLITNU {level=3}  // "The enumeration type '%s' should not contain more than %d literals"
  STDPKG {level=3}  // "The IEEE package '%s' should not be used"
  DESULN {level=3}  // "The length of design-unit '%s' should not exceed %d lines"
  INSTLB {level=3}  // "Component instance label '%s' exceeds %d characters"
  MISUSC {level=3}  // "Library '%s' is used without a 'use' clause"
}


category RTL_CODINGSTYLE_MIXED "coding style checks for Verilog and VHDL" default_off
{
  DFLDER {level=0} // "Parameters specified are incorrect, check LDFFPI will be ignored"
  TFARGT {level=1}  // "Task/function call argument %d is of wrong type (%s vs. %s)"
  TFARGN {level=1}  // "Task/function call has wrong number of arguments"
  UNCONN {level=1}  // "%s port '%s' defined in design-unit '%s' is not connected in its instance '%s'"
  UNCONI {level=1}  // "Input port '%s' of entity/module '%s' is being used inside architecture/module, but not connected (either partially or completely) in its instance '%s'"
  UNCONO {level=1}  // "Port '%s' (which is being used as an output) of entity/module ' %s' is being driven inside the design, but not connected (either partially or completely) in its instance '%s'"
  CONSTC {level=1}  // "Constant conditional expression encountered"
  CNSTCN {level=1}  // "Conditional expression is statically evaluated to %s"
  SHFTNC {level=1}  // "Shift by non-constant"
  UELCIT {level=1}  // "Unequal length in case item comparison (selector is %d bits, case tag expression is %d bits) in module/design-unit %s"
  UELOPR {level=1}  // "Unequal length operand in bit/arithmetic operator %s in module/design-unit %s"
  INTTOB {level=1}  // "Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit %s"
  CNSTCI {level=1}  // "Case expression is not a constant"
  TRUNCC {level=1}  // "Truncation of bits in a constant in module/design-unit %s.  The most significant bits are lost"
  TRUNCZ {level=1}  // "Truncation in constant conversion without a loss of bits in module/design-unit %s"
  TROPCC {level=1}  // "The result of the '%s' operation between constants in expression '%s' leads to truncation of bits and loss of data in module/design-unit %s""
  TROPCZ {level=1}  // "The result of the '%s' operation between constants in expression '%s' leads to truncation of bits but without loss of data in module/design-unit %s""
  ULRELE {level=1}  // "Unequal length operands in relational operator (padding produces incorrect result) in module/design-unit %s -- LHS operand is %d bits, RHS operand is %d bits"
  ULCMPE {level=1}  // "Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit %s. LHS operand is %d bits, RHS operand is %d bits"
  CEXPOR {level=1}  // "Case item expression out of range in module/design-unit %s"
  CIMULT {level=1}  // "Case item expression covered more than once (covers same case item expression as in line %d) in module/design-unit %s"
  DNGLEL {level=1}  // "Ambiguous else statement in the nested if statement. It is recommended to enclose the inner if statement in a begin/end block"
  OOBIDX {level=1}  // "Bit/part select '%s' (%s) is outside the defined range (%d to %d)"
  NULLRG {level=1}  // "In %s '%s', node '%s' has a null range defined"
  IDXRNG {level=1}  // "Loop index is too small for the values it should take"
  CNREAL {level=1}  // "Real variable '%s' is used in module '%s'. Real variables are not synthesizable"
  CNINTB {level=1}  // "Converting integer to a single-bit constant"
  INFLOP {level=1}  // "%s '%s' contains a possibly infinite loop"
  MISSEL {level=1}  // "%s signal '%s' missing from sensitivity list of a sequential process/block"
  USESEL {level=1}  // "Signal '%s' should not be used in the sensitivity list of a sequential process/block"
  NOTECH {level=1}  // "Instance '%s' is instantiating a technology cell. Avoid using technology cells in the design"
  POOBID {level=1}  // "Variable index/range selection of '%s' is potentially outside the defined range"
  IDXTSM {level=1}  // "Variable index/range selection of '%s' is too small to access its defined range completely"
  NEQPRM {level=1}  // "Size mismatch between formal %s parameters of function '%s'"
  ASNRST {level=1}  // "%s '%s' has '<active_low/high>' asynchronous set/reset '%s' as against the recommended '<active_high/low>' style"
  SNCRST {level=1}  // "%s '%s' has '<active_low/high>' synchronous set/reset '%s' as against the recommended '<active_high/low>' style" 
  CBYNAM {level=1}  // "Port connections for instance '%s' of module '%s' should be made by name rather than by positional ordered list"
  SYNPRT {level=1}  // "Output port '%s' is assigned asynchronously"
  TSMHOL {level=1}  // "Tri-state module '%s' contains other logic"
  CDEATF {level=1}  // "Conditional expression always evaluates to %s in module/design-unit %s"
  ONPNSG {level=1} // "The signal '%s', defined in %s '%s', is a one pin bus in its instance '%s'"
  LDFFPI {level=1} // "The logic depth between %s '%s' and %s '%s' is more than %s"
  CLKUCL {level=1}  //The clock '%s' drives a combinational logic. Depth '%d' exceeded at '%s'" 
  RSTUCL {level=1}  // "The set/reset '%s' drives a combinational logic. Depth '%d' exceeded at '%s'"
  CDEFNC {level=1}  // "Case statement %s" 

  ALOWID {level=2}  // "Signal/variable name '%s' does not follow the active-low naming convention"
  PBYNAM {level=2}  // "Named association should be used in the parameter list for %s call '%s'"
  TIESUP {level=2}  // "The output/inout '%s' is tied to supply0/supply1"
  TIELOG {level=2}  // "The output/inout '%s' is assigned a constant logic value"
  TFWARG {level=2}  // "Too few arguments passed to switch/gate"
  BOUINC {level=2}  // "Lower bound of '%s' is not '%d' in module/design-unit %s"
  INPASN {level=2}  // "Assignment to a module/task/function input port '%s' is not supported"
  DCLSCP {level=2}  // "Variable '%s' defined in scope '%s' is also defined in parent scope '%s'"
  UNDRIV {level=2}  // "Primary output/inout '%s' is not driven in the module '%s'"
  PUNDRV {level=2}  // "Primary output/inout '%s' is not fully driven in the module '%s'"
  CNSTLT {level=2}  // "Literal '%s' should be replaced with a constant"
  USEFTN {level=2}  // "Function '%s' is unused"
  USEPRT {level=2}  // "The input/inout port '%s' defined in the %s '%s' is unused (neither read nor assigned) "
  UASPRT {level=2}  // "The input/inout port '%s' defined in the %s '%s' is unassigned, but read"
  URDPRT {level=2}  // "The input/inout port '%s' defined in the %s '%s' is unread, but assigned"
  SHFTOF {level=2}  // "Shift overflow in module/design-unit %s, some bits will be lost"
  REALCM {level=2}  // "Real operand used in logical comparison"
  EXTEND {level=2}  // "Extension of '0' bits in a constant in module/design-unit %s"
  PADMSB {level=2}  // "Constant '%s' will be left-padded by %d '0' bits in module/design-unit %s"
  NULCSE {level=2}  // "Null statement should not be used in 'when others' clause in the case statement"
  REALCT {level=2}  // "Real comparison in case expression in instance/module %s"
  WIDSEL {level=2}  // "Case statement with no default. Case is too wide to check if all cases are covered"
  NESTIF {level=2}  // "Nested ifs. Consider using a %s statement instead"
  MEMSIZ {level=2}  // "Memory declaration for '%s' defines a single-bit memory word. Check for error in register declaration"
  OUTINP {level=2}  // "Primary output port %s of module %s may be driven outside the module"
  RDREAL {level=2}  // "Real literal is rounded to the nearest integer"
  CNTIME {level=2}  // "Time variable '%s' is used in %s '%s'. Time variables are not synthesizable"
  FTNEXT {level=2}  // "Function '%s' must have only one return statement, which is the last statement in the function"
  UNRCHC {level=2}  // "Code written after the unconditional return or break is unreachable"
  FFASMX {level=2}  // "In the specified always/process block, descriptions of flip-flops with and without asynchronous set/reset are mixed. Flip-flops without asynchronous set/reset are: %s"
  AVDREC {level=2} // "Function '%s' is called recursively in %s '%s'" 
  LMTSTS {level=2} // "The number of states %d should be limited to %d"
  NUMSUF {level=2}  // "Identifier '%s' has a numeric value suffix"
  POIASG {level=2}  // "The result of %s operation may lead to a potential overflow in module/design-unit %s" 
  OPRCAT {level=2}  // "Arithmetic operation performed in one or more operands of '%s' operation"
  TRIWAR {level=2} // "Tri-state logic used within an %s block"
  TBNNAM {level=2} // "Testbench '%s' does not follow the recommended naming convention"
  TBNSTP {level=2} // "Testbench '%s' terminates with '$stop'"
  IPRTEX {level=2} // "%s is used in a port expression"
  PRMEXP {level=2} // "%s '%s' used in a port expression"
  USEPKG {level=2} // "Package '%s' is unused"
  IOPNTA {level=2} // "Port '%s' is of type inout"
  IOCPIO {level=2} // "Inout '%s' is directly connected to input/output '%s'"
  RSTDAS {level=2} // "Reset deassertion synchronizer detected at '%s'"
  RSTDMN {level=2} // "Path from flip-flop %s to flip-flop %s is controlled by different reset domains"
  RSTSCB {level=2} // "Reset synchronizer with combinatorial logic detected at '%s'"
  RSTSYN {level=2} // "Reset synchronizer detected at '%s'"
  STYVAL {level=3}  // "Numeric value '%d' used for identifier '%s'. Use constants to avoid portability issues"
  SYNSCU {level=3} // "Embedded synthesis script used in the design"
  MPCMPE {level=3}  // "Expression uses '%d' operands without parentheses, which exceeds the recommended limit of '%d' operands"
  MICAWS {level=2}  // "Multiple if/case statements present in a single always construct"
  LOOPTM {level=2}  // "Logic or Relational operation between a loop variable and a non-constant value is repeated more than %d times"
  IFXZWC {level=3} // "Conditional expression evaluates to 'x' or 'z'"
  SEQCOM {level=3} // "Combinational logic detected in specification of sequential block for flop '%s'"
  FFNMOD {level=2} // "'%s' type flip-flop/latch '%s' should have a separate level of hierarchy"
  IOCOMB {level=3} // "Combinational path detected between top-level input '%s' and top-level output '%s'"
}

category RTL_CODINGSTYLE_ASSERTIONS "coding style checks for Assertions" default_off
{
  OOMRNM  {level=4} // "Hierarchical reference '%s' passed as the DUT signal to %s '%s'"
  LABMIS  {level=4} // "%s identifier '%s' not specified in the corresponding %s statement"
}
 
category RTL_SIMRACE_VERILOG "Verilog only simulation race condition checks" default_on
{
  RWRACE {level=0}  // "A read/write race exists between '%s' and '%s'"
  WWRACE {level=0}  // "'%s' is written in more than one process"
  TRRACE {level=0}  // "A trigger-propagation race exists between '%s' and '%s'"
  NBCOMB {level=1}  // "Non-blocking assignment encountered in a combinational block"
  BLKSQB {level=1}  // "Blocking assignment encountered in a sequential block"
  BLNBLK {level=1}  // "Signal '%s' is assigned via both blocking and non-blocking assignments"
}



category RTL_SIMSYNTH_VERILOG "Verilog only pre and post-synthesis simulation mismatch checks" default_on
{
  EVTRIG {level=0}  // "Always block with no event trigger at the start in module '%s'"
  LPVRMA {level=0}  // "The loop variable '%s' is used in multiple always blocks"
  METAEQ {level=0}  // "In module '%s', %s comparison is treated as %s"
  METACX {level=1}  // "In module '%s', case item expressions evaluating to 'x' are ignored"
  METACZ {level=1}  // "In module '%s', case item expressions evaluating to 'z' are ignored"
  FNAVPC {level=1}  // "Function '%s' is not assigned a value in some of the branches of conditional statement(s)"
  CODNCR {level=2}  // "Signal '%s' used in conditional expression has dont care value"
  EXLTRS {level=2}  // "Expression in the conditional logic of tri-state buffer '%s'"
  CASEZU {level=2} // "Casez statement used in the design unit '%s'"
  RDBFAS {level=2}  // "Register '%s', assigned using blocking assignment, is being read before getting assigned"
  NCASEX {level=3}  // "'casex' statement used in module '%s'"
  NFCASE {level=3}  // "'full_case' synthesis directive used in module '%s'"
  HASUPC {level=3}	// "The module '%s' contains the '%s' case"
}


category RTL_SIMSYNTH_MIXED "Verilog/VHDL pre and post-synthesis simulation mismatch checks" default_off
{
  SYNTXZ {level=0}  // "Synthesizing 'x'/'z' values in %s '%s'"
  METACO {level=0}  // "In module '%s', conditional expression containing 'x'/'z' is statically evaluated to false"
  PRTMIS {level=0}  // "There is a difference of width between the Verilog Module Port '%s' and corresponding VHDL entity/component port.This may result into synthesis/simulation mismatch"
  INTTAG {level=0}  // "In module %s, integer tags have been re-sized. This can cause a simulation mismatch"
  SENCMW {level=0}  // "Sensitivity list incomplete for node %s[%d:%d] in %s. Missing signal(s): %s"
  SUTHRU {level=0}  // "Possible shoot-through due to this assignment"
  EXTENX {level=1}  // "Extension of 'x' bits in a constant"
  EXTENZ {level=1}  // "Extension of 'z' bits in a constant"
  SLVMOD {level=1}  // "Identifier '%s' appearing in the sensitivity list is modified inside the block"
  SLRANG {level=1}  // "Range '%s' used in the sensitivity list is not complete. This could lead to differences in simulation/synthesis"
  SLVUSE {level=1}  // "Variable '%s' appearing in the sensitivity list is not used in the always block"
  MXTSBC {level=1}  // "Node '%s' has '%d' tri-state buffers connected, which exceeds the recommended limit of '%d'"
  TSBNTH {level=1}  // "Logic driven by tri-state buffer '%s' is not in a separate module"
  FASNSR {level=1}  // "In module/design-unit '%s', flip-flop has both asynchronous set and reset signals"
  IGNDLY {level=2}  // "Lumped delay in %s '%s' is ignored"
  NDLYFF {level=2}  // "No delay is set for FF inferences"
  BITUSD {level=2}  // "The bus variable '%s' appears in the sensitivity list, but all the bits are not used within the block"
  HASLEX {level=2}  // "The design contains 'synthesis_off/synthesis_on' pragmas"
  MDLDCL {level=2}  // "Signal '%s' is declared as '%s'. Use of '%s' can lead to simulation/synthesis mismatch"
  HASPGM {level=2}  // "The design contains pragma directives"
  LEXPGM {level=2}  // "File contains lexical pragmas, however it is not compiled with pragma/lexpragma command-line option."
  PRBULT {level=2}  // "Pragma '%s' applied to function"
  PGMIGR {level=2}  // "Statements from lines %d to %d, in the source file \"%s\", are under \"synthesis_off/on\" pragma. The semantics of the design may differ from simulation semantics"
  PGMCIG {level=2}  // "The design construct is under \"synthesis_off/on\" pragma. The semantics of the design may differ from simulation semantics"
}



category RTL_SYNTH_VERILOG "Verilog only synthesizability checks" default_on synth_only
{
  EVTINV {level=0}  // "The specified event expression cannot be synthesized"
  EVTDCL {level=0}  // "Module %s contains non-synthesizable named event declaration %s"
  EVTCTL {level=0}  // "Module %s contains non-synthesizable named event control %s"
  NOFREL {level=0}  // "%s %s contains non-synthesizable force/release constructs"
  NOWAIT {level=0}  // "%s %s contains non-synthesizable wait construct"
  NOFKJN {level=0}  // "%s %s contains non-synthesizable fork-join constructs"  
  NFOREV {level=0}  // "Module %s contains non-synthesizable forever construct"
  USGTSW {level=0}  // "\"%s\" not supported"
  PTYPUS {level=0}  // "In design-unit %s, ports of type \"%s\" are not supported"
  NONOWF {level=0}  // "now function in design-unit %s is not synthesizable"
  AMODNS {level=0}  // "Aliased modules are not supported by default. Module %s has duplicate input/inout ports which has effect of aliasing (shorting) two nets"
  INIEVN {level=0}  // "Module contains non-synthesizable initial block with event control"
  NODSBL {level=0}  // "Module %s contains unsupported disable construct"
  NSLOOP {level=0}  // "%s %s contains a non-static loop"
  NEVREP {level=0}  // "%s %s contains non-synthesizable repeat event specification"
  DPRUSP {level=0}  // "Module %s has non-synthesizable defparam statement"
  MULWIR {level=0}  // "Module %s has wire %s%s multi-driven"
  MUDREG {level=0} // "In module %s, register %s is driven in more than one block or process"
  PCAUSP {level=0} // "Module %s has non-synthesizable assign/deassign statements"
  OOMRUS {level=0}  // "Module %s has unsynthesizable OOMRs (Out-Of-Module Reference)"
  USINEV {level=0}  // "%s %s contains unsupported intra-assignment event specification"
  INTEVN {level=0} // "Module %s contains unsupported inter-statement event specification"
  CLKMIX {level=0} // "Always block has both level and edge sensitive nodes in its sensitivity list"
  HDLBND {level=0}  // "Module '%s' specified through the 'bind_top' option has constructs other than bind statements specified in it. Only bind statements present in this module will be recognized and all other constructs will be ignored by the tool"
  NOIVAL {level=0}  // "The initial value is missing in the declaration of constant '%s'"
  UNSINI {level=0}  // "Increment/Decrement operators in the port connection of an instance are not supported by the tool. Remodel the design without using these operators"
  VLPMWL {level=0}  // "Value of loop variable '%s' modified within the loop"
  TCLKED {level=0}  // "%s of signal '%s' used in task '%s'"
  CELVEC {level=1}  // "No re-timing will be done for %s cell"
  INFREC {level=1}  // "%s %s contains possibly unbounded subprogram recursions"
  LRGARR {level=1}  // "The given assignment has a very large variably indexed node on the left hand side, processing the statement may be very time-consuming"
  NOASLD {level=1}  // "In module %s, asynchronous load is not inferred for node %s[%d:%d]"
  MULNBA {level=1} // "In module '%s', register '%s' has multiple non-blocking assignments%s"
  UCLPNS {level=1} //  "In design-unit '%s', an unconditional loop statement is encountered"
  MULIFF {level=1}  // "Always block has multiple event controls with associated 'iff' qualifiers"
  ASNIFF {level=1}  // "Always block has an asynchronous control with associated 'iff' qualifier"
  NOCOMB {level=1}  // "The  node '%s' models a %s in an 'always_comb' block"
  NLATCH {level=1}  // "The  node '%s' models a %s in an 'always_latch' block"
  NOFLOP {level=1}  // "The  node '%s' models a %s in an 'always_ff' block"
  MTCOND {level=1}  // "The specified case statement with a 'unique' keyword has more than one case item that matches the case expression"
  NTCOND {level=1} // "The specified case statement with a 'unique' or 'priority' keyword does not have any case item that matches the case expression"
  IGPRAG {level=1} // "The tool does not support unique/priority constructs in edge sensitive sequential blocks. This construct will be ignored by the tool"
  FFLRFR {level=1}  // "Flip-flop '%s' has reset/set and logic section in the same '%s' loop"
  FFALWR {level=1}  // "If statement specifying an asynchronous '%s' '%s' is not the first statement of the always block"
  FFRSTV {level=1}  // "The %s signal '%s' is inferred as a vector"
  MULBAS {level=2} // "In module '%s', register '%s' has multiple blocking assignments%s"
  NOLOCL {level=2}  // "In module %s, local nodes of task/function %s are initialized"
  INIUSP {level=2}  // "Module %s has an initial block or a variable declaration assignment, which is ignored by synthesis tools"
  FINUSP {level=2}  // "Module '%s' has a final block, which is ignored by synthesis tools"
  IGNIFF {level=2}  // "The 'iff' qualifier, associated with the event expression with no edge specification, is ignored"
  IFFASU {level=0}   //SystemVerilog 'iff' construct is not supported in the event expression of assertions. The assertion will be ignored
  LOCVAR {level=0}   //SVA local variables are not supported by the tool, therefore, the property will be ignored. Remodel the property without using local variables
  LVRENM {level=0}   //SVA local variables of enumerated type are not supported by the tool. Remodel the property without using enumerated type
  LVMULT {level=0}   //The tool does not support multi-dimensional SVA local variables.  The property will be ignored by the tool
  PARPRP  {level=0}  //Parameterized properties are not supported by the tool. The property will be ignored. Remodel the property in non-parameterized form
  SVFCLK {level=0}   //The tool supports SystemVerilog sampled value functions for posedge/negedge clock expressions. This expression will be ignored by the tool
  SVFEVT {level=0}   //The tool does not support clocking of complex expressions for SystemVerilog sampled value functions. This expression will be ignored by the tool
  UNSFLS  {level=0}  //An out of module reference or an interface reference to a structure field  %s is  not supported by the tool.Remodel your design accordingly.
  UNSTYP {level=0}  //The data type of the variable '%s' is either not supported or not synthesizable. Remodel the design without the specified construct
  BBXMEM {level=0}  //Memory '%s' has size more than %d. This memory will be blackboxed
  CONFAL	{level=0}  //The tool could not find the port name `%s` in the instantiated module and therefore dropped the instance. Remodel your design
  UNSINC {level=0}  //Increment/Decrement(++/--) operators inside case expressions are not supported by the tool. Remodel the design without using these operators
  UNSALS  {level=0}  //The specified format of the alias module is not supported by the tool. An alias module with only empty module and one duplicate input/inout port is supported. Remodel the design accordingly
  FULCAS {level=0}   //Fullcase pragma encountered in module %s
  IGNGAT  {level=0}  //%s gate is being ignored
  IGNSYS  {level=0}  //System function call is being ignored and the return value is assumed as 0
  IGNTXZ  {level=0}  //Table row with \'X/Z\' is being ignored
  INITBI {level=0}   //Initial block in primitive is ignored
  TRWIRE {level=0}   //The trireg net type is unsynthesizable. The tool will treat trireg net '%s' as a wire
  METACA  {level=0}  //In module %s, %s tags evaluating to %s are ignored
  METACD  {level=0}  //In module %s, %s selectors with x/z is encountered"
  PARCAS {level=0}   //Parallel Case pragma encountered in module %s 
}


category RTL_SYNTH_VHDL "VHDL only synthesizability checks" default_off synth_only
{
  GENTYP {level=0}  // "The generic '%s' is not of an authorized type"
  SHRVNS {level=0}  // "Shared variables are not synthesizable"
  GRDASN {level=0}  // "In design-unit %s, non-synthesizable guarded assignments are encountered"
  WAITML {level=0}  // "In design-unit %s, multiple edges are specified after wait-until statement"
  SLDIRW {level=0}  // "Inconsistent direction in slice discrete range"
  NOEXPN {level=0}  // "Exponentiation operator is not synthesizable"
  EXPCHR {level=1}  // "Expecting character strings for encoding of user-defined enumeration types in VHDL"
  STDMBC {level=1}  // "Call to STD_MATCH will result in boolean-value comparison"
  RECATT {level=1}  // "Invalid use of attributes. Incorrect modeling style used"
  NONGEN {level=2}  // "No default value specified for generic %s in design-unit %s"
  TOPGEN {level=2}  // "Top-level design-unit '%s' has generic '%s' without a default value" 
  CFEINT {level=0}   //*internal*...processing terminated due to signal %s
  ENDPUS  {level=0}  //An endpoint was encountered in an unsupported context. This will be ignored
  PRMPRP  {level=0}  //Parameterized properties are not supported in VHDL. The property will be ignored. Remodel the property in non-parameterized form
  PRTCON {level=0}   //Open connection detected for port '%s'
  RNGCON {level=0}   //The tool has encountered a range constraint violation. Remodel  your design to remove violation
  CLKMED {level=1} // "Node %s in design-unit %s, is being driven at %s"
  STDIEE  {level=0}  //Using IEEE library located at path '%s' which is %s
  FTLGEN {level=0}   //Top-level design-unit '%s' has generic '%s' without an assigned value
  UUSAOR {level=0}  //In design-unit %s, use of array of records not supported
  OUTRNE {level=0}   //Bit/part select %s is outside the defined range %s
  IGNRIF  {level=0}  //if label is being ignored
  NODELY  {level=0}  //In design-unit %s, a VHDL wait condition without any signal to wait until or wait on has been encountered
  NODVAL  {level=0}  //Port %s of the component instance %s is not connected and has explicitly defined default value
}


category RTL_SYNTH_MIXED "Verilog and VHDL  synthesizability checks" default_off synth_only
{
  RECFLE {level=0} // "No combinational circuit or sequential element could be recognized for %s.%s[%d:%d]. The sensitivity list will be used as the trigger"
  AMSDES {level=0} // "Analog constructs detected in design %s"
  ARCONV {level=0} // "Array size/shape mismatch in explicit type conversion"
  NULLRG {level=0} // "In %s '%s', node %s has a null range defined"
  NLCRNG {level=0} // "Range evaluates to a null range"
  LPNTEX {level=0} // "The loop range of the specified for loop is a null range"
  NSLOOP {level=0} // "%s %s contains a non-static loop"
  VARRNG {level=0} // "Left and right bounds must be constant valued expressions"
  IMPFSM {level=0} // "%s %s contains implicit finite-state machine"
  SENCMW {level=0} // "Sensitivity list incomplete for node %s[%d:%d] in %s. Missing signal(s): %s"
  OUTRNG {level=0} // "Bit/part select '%s' is outside the defined range %s"
  AWNDEL {level=0} // "%s block with no event trigger at the start in %s %s"
  CLKASY {level=0} // "For node %s in design-unit/module %s, clock signal %s is used in asynchronous control"
  CLKATR {level=0} // "For node %s in design-unit %s, non-synthesizable use of attribute event on %s"
  CLKBED {level=0} // "In module/design-unit %s, clock signal %s, for node %s, is driving data on both edges. Wrong polarity specified"
  CLKEXP {level=0} // "In module/design-unit %s, for flip-flop %s, clock is an expression"
  CLKMUL {level=0} // "In module %s, node %s has multiple clocks specified"
  CLKENF {level=0} // "A conditional check is expected for all edge sensitive nodes except clock"
  CLKNED {level=0} // "In module/design-unit %s, clock signal %s for node %s does not drive any data. Wrong polarity specified"
  CLKOUT {level=0} // "In module/design-unit '%s', for flip-flop '%s', clock signal '%s' is used as the output"
  CLKSRD {level=0} // "In module/design-unit '%s', clock signal '%s', for flip-flop '%s', is used as %s"
  RSTEXP {level=0} // "In module/design-unit '%s', for flip-flop '%s', reset is an expression"
  OUTORG {level=0} // "Range constraint violation in design-unit %s"
  PRTNLL {level=0} // "A port of this instance is considered as undriven due to the presence of unsupported construct(s)"
  DRPBLK {level=0} // "The %s is being dropped due to the presence of unsupported construct(s)"
  SFNUNS {level=0} // "System function calls are not synthesizable"
  LOCOFA {level=0} // "Loop condition is always false"
  XINASN {level=0} // "In module/design-unit '%s', asynchronous set/reset force of flip-flop has x"
  LATBAS {level=0} // "In module/design-unit %s, latch is assigned by blocking assignments"
  MISNOD {level=0} // "'.*' could not infer any implicit port connection corresponding to port %s. This port will be left unconnected."
  TXTPNS {level=0} // "In design-unit %s, unsynthesizable procedure call %s from text packages encountered"
  UNSCON {level=0} // "Unsupported declaration/construct, will be ignored: %s"
  USATYP {level=0} // "In design-unit %s, objects of unsynthesizable access type are encountered"
  INTTAG {level=0} // "In module %s, integer tags have been re-sized. This can cause a simulation mismatch"
  NOACCD {level=0} // "In design-unit %s, unsynthesizable access type declaration encountered"
  NOALLD {level=0} // "In design-unit %s, unsynthesizable allocator/deallocate is encountered"
  NOASST {level=0} // "In design-unit %s, unsynthesizable assertion statement is encountered"
  PHYSNS {level=0} // "Literal physical data in design-unit %s is not supported"
  NOCASS {level=0} // "In design-unit %s, unsynthesizable concurrent assertion statement is encountered"
  USFTYP {level=0} // "In design-unit %s, objects of unsynthesizable file type are encountered"
  NODSCN {level=0} // "Disconnect specification in design unit %s not supported"
  USUPTE {level=0} // "Unsupported Table Entry"
  FILENS {level=0} // "File type declarations are not synthesizable and will be ignored"
  FILEOP {level=0} // "In design-unit %s, file operation %s is not synthesizable"
  BOXERR {level=0} // "Module/Design-unit %s is being blackboxed with option %s and simultaneously being glassboxed"
  TBBERR {level=0} // "Specified top %s is not available in the design hierarchy because instance %s of module %s is blackboxed under option %s"
  TBXERR {level=0} // "Specified top %s is also blackboxed under option %s; therefore this tool is unable to process the specified sub-design"
  IFINST {level=0} // "SystemVerilog Interface instance '%s' is connected to instance '%s' defined as a user-defined top"
  IGNINS {level=0} // "The instance '%s' in module/DU '%s' has been dropped because of errors on the formal ports of the module it is instantiating"
  INVCOE {level=0} // "Expression with invalid concatenation repeat count is being ignored"
  INVGEN {level=0} // "The specified generic/parameter does not have a valid value"
  MNTPMX {level=0} // "The (minimum, typical, maximum) delay expression is ignored, because delays are not considered during functional verification"
  LANERR {level=0} // "Design has wrong language construct for %s package"
  LRGMOD {level=0} // "The total size of the module %s is greater than that can be processed by the tool"
  NCMNOA {level=0} // "Actual argument of type attribute to nc_mirror is not supported. The nc_mirror procedure will be ignored"
  NCMNOD {level=0} // "The %s %s you have passed to nc_mirror call does not exist. The nc_mirror procedure will be ignored"
  NCMOMR {level=0} // "OOMR is not supported for destination in nc_mirror. The procedure will be ignored
  NCMSLC {level=0} // "Indexed/Slice expressions are not supported as destination or source in nc_mirror"
  NULSLC {level=0} // "Null slice range of slice expression encountered"
  SLDIRE {level=0} // "Inconsistent direction in slice discrete range"
  STMISM {level=0} // "There is a mismatch between the size of connecting variable and the instantiated module port. The instance with the implicit port connection will be ignored. Use explicit named or positional connection syntax"
  UNSPTP {level=0} // "Top-level module/entity has ports of unsupported types"
  UNSYNT {level=0} // "The statement has an unsynthesizable expression and will be ignored by the tool. Modify the design for proper functioning of the tool"
  LHSCON {level=0} // "A constant expression has been encountered on the left hand side of an assignment. The instances of this module will be ignored"
  USTYPE {level=0} // "In design-unit %s, \"%s\" type is not supported"     
  LTASRT {level=0} //  "Latch '%s' has an asynchronous set/reset" 
  ARSHMM {level=1} // "Array size/shape mismatch"
  COMBLP {level=1} // "In %s %s, combinational loop detected for node %s"
  PACSIG {level=1} // "In design-unit %s, read/write operation is performed on signal \"%s\" which is declared in package \"%s \""
  FNORET {level=1} // "Function has no return value and function return type is unconstrained"
  WNORET {level=1} // "Function has no return value"
  ASNCLD {level=1} // "In module %s, asynchronous load is inferred for node %s[%d:%d]. A synchronous reset may also be generated, if there is an error in the polarity of the reset signal"
  CELLOP {level=1} // "Cell %s may have combinational loops. Node %s is one of the nodes contributing to this potential loop"
  CLKINP {level=1} // "In %s %s, clock signal %s, for flip-flop %s, is not an input"
  CLKLST {level=1} // "For node %s in design-unit/module %s, assignment under the clock single-edge condition expression must be the last assignment at this level and there must not be any assignment when this condition is false after this assignment"
  CLKMBT {level=1} // "In %s %s, multi-bits %s used as clock for flip-flop %s"
  RSTINP {level=1} // "In %s '%s', reset signal '%s', for flip-flop '%s', is not an input"
  BLKBOX {level=1} // "%s %s automatically blackboxed"
  RLRINT {level=1} // "Real literal is rounded to the nearest integer"
  IGNENC {level=1} // "Enum encoding of the enum type is being ignored"
  ASYNLD {level=1} //  "Asynchronous load is inferred for node %s. A synchronous reset may also be generated, if there is an error in the polarity of the reset signal"
  ARNSOP {level=1} // "Logic operator other than '!' or '~' used to describe asynchronous set/reset of flip-flop '%s'"
  EMTFNC {level=2} // "Function definition has an empty body"
  PGMENB {level=2} // "Statements from lines %d to %d, in the source file \"%s\", are under \"verification_on/off\" pragma. These statements will be processed"
  PGMIGR {level=2} // "Statements from lines %d to %d, in the source file \"%s\", are under \"synthesis_off/on\" pragma. The semantics of the design may differ from simulation semantics"
  PGMTSO {level=2} // "Basetype/subtype of \"%s\" has declaration under \"synthesis_off/on\" pragma"
  PGMUSO {level=2} // "\"%s\" has declaration under \"synthesis_off/on\" pragma"
  PGMEXP {level=2} // "Incorrect use of Expression level \"synthesis_off/on\" Pragma for \"%s\""
  SKPSUP {level=2} // "Assignment to a supply0/supply1 net %s in module %s is ignored"
  EMPBLK {level=2} // "Module %s has an empty block"
  RSTOUT {level=2} // "In module/design-unit %s, for flip-flop %s, reset signal %s is used as the output"
  EMPMOD {level=2} // "Module/Design-unit '%s' is empty"
  IGNATP {level=2} // "Ignoring attribute parameter on attribute %s"
  EXPBBX {level=3} // "Design contains explicitly blackboxed design units"
  IMPBBX {level=3} // "Design contains implicitly blackboxed memories"
  EXPGBX {level=3} // "Design contains explicitly glassboxed design units"
  AUTOBX {level=3} // "Design contains implicitly blackboxed design units/memories"

  LDSNAP	{level=0}   //Loading design snapshot
 TDHIER {level=0}   //Traversing design hierarchy
 TOTFSM	{level=0}   //Total FSMs extracted = %d
 TOTERR	{level=0}   //Total errors   = %d
 TOTWAR	{level=0}   //Total warnings = %d
 MAXWRN {level=0}   //Maximum warning count reached (%d). All further warnings will be ignored
 MESSG1	{level=0}   //%s
 MESSG2	{level=0}   //%s %s
 UNIQUE {level=0}   //%s : %s %s
 NOSMVG {level=0}   //Errors encountered in processing
 NOLICF {level=0}   //License initialization failed
 ADDLIN {level=0}   //%s Source HDL information for the error/warning mentioned above
 FTLMEM {level=0}   //Processing stopped because virtual memory limit exceeded
 FTLWRN {level=0}   //Processing stopped because of the error/warning above
 NOARGS {level=0}   //No argument passed for the command line option %s. Therefore, this option is being ignored
 USBIND  {level=0}  //The tool does not support the SystemVerilog bind construct. Remodel the design without using the bind construct
 CURREV	{level=0}   //Current revision is %03d
 MIXLAN  {level=0}  //Mixed-language designs are not supported
 EMULTO  {level=0}  //Multiple tops found in the design
 MUSNAP  {level=0}  //The snapshot contains multiple top-level modules. The tool does not support designs with multiple top-level modules. Reinvoke the tool  with '-TOP' or '-inst_top' command line option to specify the top module name
 NODSGN  {level=0}  //Design top module could not be found by the tool. Only the module(s) specified with 'bind_top' option were found in the snapshot. Specify the design modules before invoking the tool again
 SSNINC  {level=0}  //The incremental snapshot '%s' cannot be analyzed
 PROGBX {level=0}   //%s %s has been glassboxed by the tool as it contains protected HDL
 BLFNUS {level=0}   //PSL built-in function '%s' is not supported by the tool
 BPSFNA  {level=0}  //Bit-select or part-select is not allowed on a forall replicator.  Modify the property before invoking the tool again
 DRPBLE {level=0}   //The %s is being ignored due to the presence of unsupported construct(s)
 EVTUNS  {level=0}  // The tool does not support usage of %s in an event expression. The property will be ignored by the tool
 IGNPTH {level=0}   //The tool has encountered error(s) in the %s, the %s is being ignored
 IGNASN {level=0}   //Due to an error on the node '%s', all the assignments to the node will be ignored
 LVMXSZ {level=0}   //The tool does not support %s SVA local variables of size greater than %s. The property will be ignored by the tool
 NCMUNS  {level=0}  //The %s is not a valid source object for nc_mirror. The nc_mirror procedure will be ignored. A valid source object can be a VHDL signal, variable, port, generic, or a Verilog wire
 NCUNPK  {level=0}  //The tool does not support indexed/sliced expressions of signals with unpacked structures in nc_mirror. This expression will be ignored by the tool
 OMRPWR {level=0}   //OOMR %s has been used at Output/Inout port. This is not supported and will be ignored by the tool.Remodel your design
 OMRWNS {level=0}   //OOMR write is not supported and will be ignored by the tool.Remodel your design
 PGMCEN  {level=0}  //The design construct is under \"verification_on/off\" pragma. This construct will be processed
 PRMIDX {level=0}   //Indexing of formal parameters of properties are not supported. The property will be ignored
 SVFCKE {level=0}   //Specifying %s as an argument to the sampled value function is not supported. This expression will be ignored by the tool
 SIFVIG {level=0}   //SystemVerilog '%s' construct is supported only with sysv command line option. This construct will be ignored by the tool. Specify sysv option along with the invocation to enable this support
 SYSVLG {level=0}   //SystemVerilog constructs are not presently handled by the tool. Please run ncvlog without -SV31A option
 UNCINE  {level=0}  //Component instance is not fully bound (%s)
 UNKNWN  {level=0}  //The tool will always evaluate the function 'isunknown' to be false
 UNSYNP {level=0}  //The property has an unsynthesizable expression and will be ignored by the tool. Modify the expression for proper functioning of the tool.
 USFERO {level=0}  //'rose'/'fell' function call with argument of width more than one is not supported
 VALRAO  {level=0} //Range of values specified to the forall operator must be in ascending order else the property will be ignored. Modify the property by specifying the range in ascending order
 VALPOS {level=0}  //Range of values specified to the forall operator must evaluate to a positive integer or zero else the property will be ignored. Modify the property by specifying the range with a positive integer or zero
 BBXSIG {level=0}  //The size of signal '%s' is greater than %d which is specified with BB_SIGSIZE option. Signal '%s' will be blackboxed and all assignments to the signal will be ignored
 IGNCMB {level=0}  //Ignoring clock generation assignment \"%s = not(%s)\"
 INFILP {level=0}  //%s %s contains loop with more than %d iterations. The loop will be blackboxed
 LRLOOP {level=0}  //Loop has more than %d iterations. Processing of loop may take some time
 LOPOPT  {level=0} //The given Loop is been internally optimized by %s optimization.
 SENCME   {level=0} //Sensitivity list incomplete for node %s%s in %s. Missing signal(s): %s
 FSMERR  {level=0}  //  FSM extraction failed due to synthesizability errors
 FSMFND  {level=0}  //  FSM extracted for state register %s
 FSMCLK  {level=0}  //FSM extraction for state register '%s' in design unit '%s' failed due to complex clock expression
 FSMSTA  {level=0}  //FSM extraction for state register '%s' in design unit '%s' failed to extract reset state
 FSMRST  {level=0}  //FSM extraction for state register '%s' in design unit '%s' failed due to complex reset expression
 VARTRE {level=0}   //The specified HDL code does not adhere to FSM modeling style guidelines. One or more transitions are expressed as assignment of non-constant expression to state register
 XZSTRN {level=0}   //The state transitions in the specified FSM assign values containing 'X' or 'Z' to the state register
 OPOVFL {level=0}   //The %s expression %s has resulted in an overflow and cannot be accommodated in %s bits. This could lead to incorrect results
 AWNDLW {level=0}   //%s block with no event trigger at the start in %s %s
 RECFAL {level=0}   //No combinational circuit or sequential element could be recognized for %s.%s%s. The sensitivity list will be used as the trigger
 MEMREC {level=0}   //Node '%s' has been identified as a memory element
 DEFVAL  {level=0}  //Using explicitly defined default value at port %s of the component instance %s because it is not connected and -USEDEFVAL option is used
 REALNS  {level=0}  //Literal real data %s in design-unit %s is not supported
 WRRMTH {level=0}   //The function %s is a standard MATH_REAL package function. It could derive incorrect results during REAL to INTEGER conversion. View the extended help for more information
 SIMBLS {level=0}   //\"%s\" is supported using simplistic boolean model
 UNSVHD	{level=0}   //VHDL200X '%s' construct is not supported by the tool.This will be ignored
 USDVAL  {level=0}  //Using explicitly defined default value at port %s of the component instance %s because it is not connected
 WAITFR  {level=0}  //In design-unit %s, a wait statement which waits for fixed time is not supported
 MIXUNS	{level=0}   //The tool does not support VHDL port connection of inout type with actual port in SystemVerilog of enum type. This module instance will be ignored by the tool
 UNSYSC {level=0}   //SystemC designs are not supported by the tool
 UNSBBC  {level=0}  //Snapshot elaborated with -BBCONNECT option is not supported. Re-invoke the tool without BBCONNECT option
 WCONSR {level=0}   //The tool only supports constant expression in the second operand of wild card equality operator ==? and !=?. The operators ==? and !=? are treated as == and != respectively
 COVDBP  {level=0}  //Unable to open simulation coverage database at %s. Regenerate the database
 NDMPCV {level=0}   //Unable to create file %s. Verify the working directory for shortage of disk space and write permissions
 UCDTST {level=0}   //Unable to access the path %s. Verify the path, shortage of disk space, and read/write permissions before invoking the tool again
 UTORDF {level=0}   //Could not open file \"%s\" for reading
 NOVPCB {level=0}   //%s scoring is not supported and will be ignored by the tool
 NOCVGL {level=0}   //Design unit %s is not consistent with the simulation coverage database and will be ignored by the tool
 NOCOVG {level=0}   //Inconsistent %s coverage option for %s between coverage database and snapshot. Provide correct coverage database or coverage option before invoking the tool again"
 NOTSIG {level=0}   //Signal %s is not found. Toggle checks are not created for the signal during coverage unreachability analysis
 NOUTSV {level=0}   //Toggle checks are not supported when -NXG_OFF option is enabled during coverage unreachability analysis. Remove this option or disable toggle checks before invoking the tool again
 CNTSOP {level=0}   //The tool does not support both control and SOP expression scoring data in simulation coverage database. Disable the expression coverage unreachability check or provide a coverage database containing either control or SOP expression scoring data
 NOCINS {level=0}  //No matching instance found in the snapshot for coverage top %s. Coverage unreachability check for %s and its subsequent hierarchies will be ignored
 NOUNIN {level=0}  //No unique instance found in the snapshot for coverage top %s. Coverage unreachability check for %s and its subsequent hierarchies will be ignored. Re-invoke the tool with -DUTINST option to consider this as coverage top
 MICTOP {level=0}  //For coverage unreachability flow, instance %s in snapshot is matched with coverage top %s
 IGNEXR {level=0}  //Invalid syntax specified on line number %s of refinement file. This line will be ignored by the tool
 CORRFL {level=0}  //%s : Invalid format specified in the refinement file. Validate the file before invoking the tool again
 IGNENM {level=0}  //Toggle analysis of SystemVerilog enumerated type is not supported in coverage unreachability flow. Signal %s will not be analyzed
 OLDREF {level=0}  //Ignoring the %s exclude rule for %s %s. Refinement files are not in synchronization with the coverage database. Check if some source file was changed and coverage database regenerated after the refinement files were created. In that case, update refinement files and rerun the tool
 UNSREF {level=0}  //Refinement file %s is not in synchronization with other refinement files. Ignoring the rule specified at line %s in the refinement file. Update %s and rerun the tool
 NODPFL  {level=0} //Unable to open .dpdata file for writing %s
 VCCNLD	{level=0}  //Unable to load VCC API library %s
 VCCSYM	{level=0}  //Could not find the required symbol %s in the VCC library
 VITBBX  {level=0} //Design-unit '%s' contains unsupported VHDL VITAL constructs. As a result, this design-unit has been automatically blackboxed. The design-unit and the sub-hierarchy under this design-unit will not be processed for FSM extraction
 LICNOF {level=0}  //The tool was unable to checkout %s license. Verify that the required %s license is available for the tools operation
 IPNOSO {level=0}  //VIP CAT 11.1 is not supported in this release. It will be supported in future releases. Use older VIP version to continue with verification
}

category FSM "Verilog and VHDL, FSM coding style checks" default_on synth_only
{
  //mcj FSMIDN {level=0} // "In module/design-unit '%s', FSM for state register '%s' has been recognized"
  TERMST {level=0} // "In module/design-unit '%s', FSM for state register '%s' has terminal states %s"
  UNRCHS {level=0} // "In module/design-unit '%s', FSM for state register '%s' has unreachable states %s"
  //mcj BADFSM {level=1} // "In module/design-unit '%s', FSM for state register '%s' does not adhere to modeling style guidelines
  PTRMST {level=1} // "In module/design-unit '%s', FSM for state register '%s' has potentially terminal states %s"
  PUNRCS {level=1} // "In module/design-unit '%s', FSM for state register '%s' has potentially unreachable states %s"
  VARTAG {level=1} // "The specified FSM contains a variable tag in the combinatorial logic"
  VARTRN {level=1} // "The specified FSM contains state transitions expressed as assignments of variables to the state register"
  EXTSEQ {level=1} // "Extraneous logic is present in the sequential portion of the FSM"
  //mcj PRMFSM {level=1} // "Parameter is not used to encode the state of the FSM" 
  //mcj ONHOEN {level=1} //  "One hot encoding not used for assigning states in state machine"
  EXTFSM {level=2} // "Extraneous logic is present in the module/design-unit '%s' containing a FSM description"
  //mcj TRNMBT {level=2} // "For the specified state '%s', the state value changes by more than one bits on transition to state(s) %s"
}



category DFT "Verilog and VHDL DFT checks" default_on synth_only
{
  CMBPAU {level=0} // "Combinational loop detected through '%s' in module/design-unit '%s'"
  ASNCFL {level=0} // "Asynchronous feedback loop detected through set/reset of flip-flop(s) and '%s' in module/design-unit '%s'"
  MULMCK {level=0} // "Multiple master clocks found. Clock '%s' for flip-flop '%s' is derived from master input '%s' while the previously detected clocks were derived from '%s' for flip-flop '%s'" 
  FFCKNP {level=0} // "Flip-flop '%s' has clock '%s' which is derived from a flip-flop"
  GTDCLK {level=0} // "Clock gating detected for clock '%s' of flip-flop '%s'"
  CLKLAT {level=0} // "Flip-flop '%s' has clock '%s' which is derived from a latch"
  CLKNPI {level=0} // "Flip-flop '%s' has clock '%s' which is not derived from master input"
  //mcj FFWASR {level=0} // "Flip-flop '%s' does not have any asynchronous set or reset"
  //mcj FFWNSR {level=0} // "Flip-flop '%s' does not have any set or reset"
  //mcj FFASRT {level=0} // "Flip-flop '%s' has an asynchronous reset"
  ACNCPI {level=0} // "Asynchronous %s '%s' of latch/flip-flop '%s' is not controllable from primary inputs"
  LENCPI {level=0} // "Enable of latch '%s' is not controllable from primary inputs"
  CLKINF {level=0} // "Clock '%s' has associated DFT violations. It was inferred as clock because it is connected to the %s pin of %s '%s'"
  CLKDAT {level=0} // "Clock signal '%s' drives the data pin of flip-flop '%s'"
  CLKLDT {level=0} // "Clock signal '%s' drives the data pin of latch '%s'"
  CDFDAT {level=0} // "Clock signal '%s' drives the data pin and clock pin %s of flip-flop '%s'"
  CDLDAT {level=0} // "Clock signal '%s' drives the data pin and clock pin %s of latch '%s'"
  CAAFSR {level=0} // "Clock signal '%s' drives a set or reset pin of flip-flop '%s'"
  CACSRF {level=0} // "Clock signal '%s' drives set/reset and clock pin %s of flip-flop '%s'"
  CACSRL {level=0} // "Clock signal '%s' drives set/reset and clock pin %s of latch '%s'"
  CAALSR {level=0} // "Clock signal '%s' drives a set or reset pin of latch '%s'"
  RSTDAT {level=0} // "Reset signal '%s' drives the data pin of %s '%s'"
  LATINF {level=0} // "Process/always block models a latch, or signal '%s' is not assigned a value in all branches"
  LCNSTD {level=0} // "Inferred latch '%s' has constant data"
  GTCLKN {level=1} // "Clock gating detected for clock '%s' of flip-flop '%s'"
  FFCSTD {level=1} // "Inferred flip-flop '%s' has a constant data input"
  MRSTDT {level=1} // "Mix of synchronous and asynchronous set/reset found. Synchronous set/reset detected in '%s' and asynchronous set/reset detected in '%s'"
  TPOUNR {level=1} // "Output '%s' of top-level module is not a register"
  NEFLOP {level=1} // "Flip-flop '%s' is triggered at the negative edge of clock '%s'"
  SLNOTP {level=1} // "Enable pin '%s' of the tristate buffer is not directly controllable by primary input(s)"
  GENTOP {level=1} // "The top module '%s' is specified as a %s generator module"
  JKFFDT {level=2} // "Flip-flop '%s' models a JK flip-flop"
  LATRAN {level=2} // "Latch '%s' is %s enable while its driving flip-flop '%s' is also sensitive at %s edge of the clock"

  // *******************************************************
  // **      TEST MODE RULES/CHECKS START FROM HERE       **
  // *******************************************************

//mcj   TCDFDT {level=0} // "In test mode, clock signal '%s' drives the data pin and clock pin %s of flip-flop '%s'"
//mcj   TCDLDT {level=0} // "In test mode, clock signal '%s' drives the data pin and clock pin %s of latch '%s'"
//mcj   TCKDAT {level=0} // "In test mode, clock signal '%s' drives the data pin of flip-flop '%s'"
//mcj   TCKLDT {level=0} // "In test mode, clock signal '%s' drives the data pin of latch '%s'"
//mcj   TMSCFF {level=0} // "Test mode signal '%s' is directly connected to %s '%s' of %s '%s'"
//mcj   ASRTSC {level=0} // "In test mode, asynchronous set/reset%s of flip-flop/latch '%s' is not controllable during scan capture"
//mcj   ASRTCL {level=0} // "In test mode, asynchronous set/reset%s of flip-flop/latch '%s' is active during scan shift"
//mcj   ASRTCK {level=0} // "Test clock '%s' drives asynchronous set/reset%s of flip-flop/latch '%s'
//mcj   SEICLK {level=0} // "Clock '%s', not bypassed in scan shift mode, is connected to clock pin of following flip-flop(s)"
//mcj   SCICLK {level=0} // "Clock '%s', not bypassed in scan capture mode, is connected to clock pin of following flip-flop(s)"
//mcj   SMTCLK {level=0} // "Clock '%s', driven by %d test clock(s) in scan mode, is connected to clock pin of following flip-flop(s)"
//mcj   TXCNOP {level=0} // "Output '%s' of tie-x cell '%s' is connected to '%s' during scan mode"
//mcj   MEMNOP {level=0} // "Output '%s' of memory cell '%s' is connected to '%s' during scan mode"
//mcj   OUTMNR {level=0} // "Output '%s', of memory cell '%s', is not registered"
//mcj   INPMNR {level=0} // "Input '%s', of memory cell '%s', is not registered"
//mcj   MCKNDB {level=0} // "Write clock '%s' of memory cell '%s' is not disabled during scan mode"
//mcj   WENNDB {level=0} // "Write enable '%s' of memory cell '%s' is not disabled during scan mode"
//mcj   TENNOD {level=0} // "In test mode, tristate buffer '%s' does not drive 'Z' during scan shift"
//mcj   TENNOC {level=0} // "In test mode, enable of tristate buffer '%s' is not controllable during scan shift"
//mcj   RSTEDG {level=0} // 	"Signal '%s' is used as both, active-high set/reset as well as active-low set/reset"
//mcj   NOTCLK {level=0} // "The following %s, in clock domain '%s', are not controlled by any test clock"
//mcj   MULTCK {level=0} // "In test mode, test domain '%s' drives multiple clock domains"
//mcj   NOTSCN {level=0} // "Flip-flop '%s' is not scannable" 
//mcj   LTCHNT {level=1} // "Latch '%s' is not transparent in test mode" 
}

category ADVANCE_DFT "Verilog and VHDL Advance DFT checks" default_off synth_only
{
  ADRSND {level=0} // "In scan shift mode, asynchronous set/reset '%s' of flip-flop '%s' cannot be controlled/disabled from top"
  MEMNCB {level=0} // "In the scan shift mode, write_enable, chip_select, and write_clock of the memory cell '%s' are not bypassed"
  CONVRF {level=0} // "Following constraints for the instance '%s', have been verified in %s mode"
  UVRFCN {level=0} // "Following constraints for the instance '%s', have not been verified in %s mode"
  OPDNMT {level=0} // "For the instance '%s', the given output port dependencies, have not been verified in %s mode"
  CONCLK {level=0} // "For the Instance %s, in the mode %s, the test clock %s is connected to the test clock %s"
  SEDFRS {level=2} // "Same second level reset disable signal found for set/reset '%s'"
  CLKNTP {level=2} // "In test mode clock '%s' of flip-flop/latch/Memory '%s' is not controllable from top"
  MULTCC {level=2} // "In scan capture mode clock '%s' of flip-flop/latch/Memory '%s' is driven by multiple test clocks"
  CGCENC {level=2} // "In scan shift mode, clock gate '%s' is not enabled/controlled from top"
  SMCKRS {level=2} // "In scan capture mode, set/reset and clock of flip-flop '%s' are transitioning together"
  MTOMPH {level=2} // "Input '%s' of the memory cell '%s' is driven by output '%s' of the memory cell '%s'"
}


category STRUCTURAL "Verilog/VHDL structural checks" default_on synth_only
{
  //mcj DEEPSG {level=0} // "The signal '%s' has depth greater than the threshold depth, Signal CC0 is '%s', CC1 is '%s' and CO is '%s'"
  LFLTSE {level=0} // "Latch '%s' is feeding latch '%s' having same enable %s"
  LFFTNE {level=0} // "Latch '%s' is feeding flip-flop '%s' which is triggered at the negative edge of latch enable %s"
  MLTDRV {level=0} // "Signal/register '%s' is multiply driven"
  MLTDIO {level=0} // "Inout Port '%s' is multiply driven"
  SUTHRU {level=0} // "Possible shoot-through due to this assignment"
  GLTASR {level=0} // "Combinatorial logic present in the path of asynchronous %s '%s' may lead to a glitch. One such affected flip-flop is '%s'"
  RSTENA {level=0} // "%s pin %s is permanently enabled"
  //mcj FDTHRU {level=1} // "Feedthrough detected from input '%s' to output '%s'"
  DFDRVS {level=1} // "Drivers of sub-parts of vector '%s' are not of same type"
  ENGTNR {level=1} // "The enable input '%s' of gated clock '%s' is %s clock input"
  INFNOT {level=1} // "Ignoring %s '%s' with no fanout to module/design-unit outputs or child instances"
  //mcj ATLGLC {level=1} // "Glue logic inferred in top-level module/design-unit '%s'"
  EDGMIX {level=1} // "In module/design-unit '%s', both positive and negative edges are used for signal '%s'"
  FRSTDF {level=1} // "Set/Reset '%s' of flip-flop '%s' is derived from flip-flop '%s'"
  FRSTDL {level=1} // "Set/Reset '%s' of flip-flop '%s' is derived from latch '%s'"
  LGRSTL {level=1} // "Combinational Logic present in the path of asynchronous %s"
  //mcj CBPAHI {level=2} // "Combinatorial path crossing multiple units drives '%s'"
  DALIAS {level=2} // "Aliased constructs found. %s '%s' and '%s' have same drivers"
  //mcj NUMDFF {level=2} // "Number of single-bit D flip-flops present in the hierarchy is %s"
  //mcj PRTDUP {level=2} // "There are duplicate ports with the name '%s' in module '%s'"
  SYNASN {level=2} // "The module/design-unit '%s' contains synchronous as well as asynchronous logic"
  MCKDMN {level=2} // "In instance '%s', clocks belong to different clock domains"
  CLKGNP {level=2} // "The clock generation logic is placed in module/design-unit '%s', which also contains extraneous logic"
  CLKGNH {level=2} // "The clock generation logic for clock '%s' is not at the same or a higher hierarchical level as the module/design-unit to which the clock applies"
  RSTGNP {level=2} // "The reset generation logic is placed in module/design-unit '%s', which also contains extraneous logic"
  RSTGNH {level=2} // "The reset generation logic for reset '%s' is not at the same or a higher hierarchical level as the module/design-unit to which the reset applies"
  //mcj MXFNOT {level=2} //"The port '%s' of design-unit '%s' has a fanout of '%d' in its instance '%s', which exceeds the recommended limit of %d"
  SELCLK {level=2} //"The selector of the mux is connected to the clock signal '%s'"
  TSBINF {level=3} // "Signal '%s' defined in module/design-unit '%s', is inferred as a tri-state buffer"
  //mcj PRTCNT {level=4} // "Module/Entity '%s' contains '%d' ports"
  MULRST {level=4} // "Flip-flop '%s' contains multiple set/reset inputs"
}



category CLOCKDOMAIN "Verilog/VHDL clock domain checks" default_on synth_only
{
  CLKDMN {level=0} // "Signal from clock domain '%s' is crossing into domain of clock '%s' at flip-flop '%s' without proper synchronization"
  INSYNC {level=1} // "%s based synchronizer detected at '%s' synchronizing from clock domain '%s' to clock domain '%s'"
  NSYLAT {level=1} // "Some instances of latch '%s' are not used as synchronizer"
  CMBCDC {level=1} // "Combinational logic is found in clock domain crossing path at '%s'"
  FLSYNC {level=1} // "Feedback loop present at the first-stage flip-flop of the 2-flip-flop based synchronizer at '%s'"

}



category SCANCHAIN "Verilog/VHDL Netlist level scan chain checks" default_off
{
  PCNOTC {level=0} // "Partial scan chain (with formal '%s') in instance '%s', is not part of any of the complete scan chains of its parent scope"
  SLENEX {level=0} // "Scan chain (from '%s' to '%s') length is '%d' which exceeds the limit '%d'"
  WRSCNL {level=0} // "'scanlengthlimit' is incorrectly specified in local.def file, taking its default value"
  DSCNCK {level=0} // "A part of scan chain starting from port '%s' is found to have clock '%s' in instance '%s', which is different from scan clock '%s'"
  DSCNEN {level=0} // "A part of scan chain starting from port '%s' is found to have scan enable '%s' in instance '%s', which is different from scan enable '%s'"
  NONSCN {level=0} // "All the instances of module/design-unit '%s' are not scannable"
  SCNLEN {level=2} // "Scan chain (from '%s' to '%s') has length '%d'"
}


category PD_NONSYNTH "Category of all the checks which are a cause of non-synthesizability of DU on Palladium, hence redirection to NC-Sim (simulator)" default_off synth_only
{
  ARSHMM  // "Array size/shape mismatch" 
  AORAGG  // "Array of record aggregates are not currently supported for arrays of unconstrained types. Remodel the design"
  AORCON  // "Array of record created using concatenation of arrays of records is not supported. Remodel the design" 
  DOMRNS  // "Disable OOMR not supported" 
  EMTFNC  // "Function definition has an empty body" 
  GRDASN  // "In design-unit %s, non-synthesizable guarded assignments encountered" 
  NONOWF  // "now function in design-unit %s not synthesizable"
  MOMRNS  // "OOMR assignment to Verilog memory not supported" 
  MUSOMR  // "Memory has unsupported OOMR assignments in the design"
  NOPATT  // "Pre-defined attribute %s in design-unit %s is not synthesizable" 
  NULSTR  // "Null strings are not supported" 
  RNGEXP  // "Type range has unsupported expressions. Only static constant expressions are allowed in the range" 
  SFNUNE  // "System function calls are not supported" 
  SOMRNE  // "OOMR subprogram (function/task) call is not supported" 
  UNCMDL  // "Unbound components exist with same name %s and different number of ports/port size" 
  UNKGEN  // "Design-unit/Module %s has Generic/Parameter of unsupported type" 
  UXUASR  // "Use of 'X' in assertions is not supported" 
  UZUASR  // "Use of 'Z' in assertions is not supported in scenarios other than bus-float checks" 
  WAVFRM  // "Multiple waveform elements are not supported. Existing in %s %s, node %s" 
  INFLOP  // "%s %s possibly contains an infinite loop" 
  INFREC  // "%s %s possibly contains unbounded subprogram recursions" 
  NLCRNG  // "Range evaluates to a null range" 
  RECATT  // "Invalid use of attributes. Incorrect modeling style used" 
  UNOMSU  // "OOMR on function/task %s using nodes outside the subprogram scope is not supported" 
  VARRNG  // "Left and right bounds must be constant valued expressions" 
  IMPFSM  // "%s %s contains implicit finite-state machine" 
  CELLOP  // "Cell %s may have combinational loops. Node %s is one of the nodes contributing to this potential loop" 
  AMODNS  // "Aliased modules are not supported by default. Module %s has duplicate input/inout ports which has effect of aliasing (shorting) two nets"
  CNREAL  // "Real variable '%s' is used in module '%s'. Real variables are not synthesizable" 
  INIEVN  // "Module %s contains non-synthesizable initial block with event control"  
  TFWARG  // "Too few arguments passed to switch/gate" 
  CLKATR  // "For node %s in design-unit %s, non-synthesizable use of attribute event on %s"  
  CLKLST  // "For node %s in design-unit/module %s, assignment under the clock single-edge condition expression must be the last assignment at this level and there must not be any assignment when this condition is false after this assignment"
  CLKMED  // "Node %s in design-unit %s, being driven at %s" 
  ARCONV  // "Array size/shape mismatch in explicit type conversion" 
  NSLOOP  // "%s %s contains a non-static loop" 
  EVTCTL  // "Module %s contains non-synthesizable named event control %s" 
  USINEV  // "%s %s contains unsupported intra-assignment event specification" 
  NEVREP  // "%s %s contains non-synthesizable repeat event specification"
  NFOREV  // "Module %s contains non-synthesizable forever construct" 
  NODSBL  // "Module %s contains unsupported disable construct" 
  NOWAIT  // "%s %s contains non-synthesizable wait construct" 
  UNDSBL  // "Module %s contains unsupported style of disable construct" 
  USGTSW  // "\"%s\" not supported"
  USSTRG  // "Nodes of composite data types, having std_ulogic type or types derived from std_ulogic in array ranges is currently not supported" 
  NULRGE  // "Node of null range is encountered" 
  NOGATE  // "Module %s contains unsupported gate type %s" 
  UUSTYP  // "In design-unit %s, use of '%s' type is not synthesizable" 
  NBFUNC  // "Non-blocking assignment encountered in function '%s'"
  SYSVNC  // "SystemVerilog construct: '%s' is unsupported by HDL-ICE, the RTL compiler of Palladium and the corresponding module would be redirected to NC-Sim"

}

category HDLICE_NOSUPP "Category of all the checks which are unsupported by HDL-ICE hence lead to redirection to SA Bin" default_off synth_only  
{
  MUDREG  // "In module %s, register %s is driven in more than one block or process"
  MULWIR  // "Module %s has wire %s%s multi-driven"
  HISTUS  // "The System task/function '%s' is not supported by HDL-ICE, the RTL compiler of Palladium"
  SPDCLK  // "Module 'SPDclkgen2' should be directed to SA"
  HIINIT  // "The initial blocks are not supported by HDL-ICE, the RTL compiler of Palladium"
  NOFREL  // "%s %s contains non-synthesizable force/release constructs" 
  UNDASS  // "Deassign statements are not supported by HDL-ICE, the RTL compiler of Palladium"
  SYSVAP  // "SystemVerilog construct: '%s' is not supported by HDL-ICE, the RTL compiler of Palladium"
  NOFKJN  // "%s %s contains non-synthesizable fork-join constructs" 
}  

category PALLADIUM "Category of all the checks to qualify design to run on Palladium" default_off synth_only
{
  // Checks which report messages in the TB/Design for Palladium Emulation

  MEMHIR  // "A hierarchical reference to the design memory '%s' found in the testbench '%s'"
  OOMRDT  // "OOMR '%s' from synthesizable module '%s' to non-synthesizable module '%s' found"
  OOMRTD  // "OOMR '%s' from non-synthesizable module '%s' to synthesizable module '%s' found"
  NOSPEC  // "%s mentioned in the specify block of module %s is ignored. Use -CONNECT_SPECIFY_BLOCK to preserve connections in the design"
  TIMCHK  // "Timing checks done in the testbench on the design input/output '%s'"
  DLYWIR  // "Delayed net '%s' which is connected to input port '%s' is being driven through timing check '%s'"
  UNSSTR  // "Unsupported %s strength '%s' passed between testbench and design through input/inout port '%s'"
  TRISTR  // "For an interface net, all tristate drivers must have both 'strong' values"
  INTCLK  // "An internal clock '%s' is detected in the design"
  CKFREQ  // "The testbench generated a clock '%s' with Time Period '%s' '%s'"
  TBZCON  // "Output net '%s' driven by output/inout port of the design is tested for 'Z'"
  TBXZDV  // "The input/inout port of the design '%s' is driven by 'X' or 'Z' through signal '%s'"
  TBZOMR  // "The signal '%s' of design '%s' is driven by 'X' or 'Z' through out of module reference from the testbench"
  BADKWD  // "Usage of the keyword \"QTSACELL\" in the module/DU name is incorrect"
  CNREAL  // "Real variable '%s' is used in module '%s'. Real variables are not synthesizable"
  MEMLOP  // "Memory %s is read or written within a loop in the design"
  SHFLAR  // "The shift register '%s' has large "shift_by" operator '%s' in the design"
  HISTIG  // "A System Task/Function '%s' in module '%s' will be ignored by HDL-ICE"
  NSDTOP  // "The DUV top '%s' is non-synthesizable"
  NSSCDT  // "The SystemC DUV top '%s' is non-synthesizable" 
  SYNTNC  // "While doing partitioning for Co-simulation flow, the synthesizable module/DU '%s' is directed to NC-Sim because its hierarchical path has behavioral source"
  ICEVHD  // "Module '%s' is directed to HDL-ICE despite the presence of constructs which are unsupported by HDL-ICE, because its hierarchical path contains VHDL entity"
  VLOGSA  // "Module '%s' is directed to sa bin because a module below its hierarchy was redirected to sa bin"
  SAFORC  // "Module '%s' cannot be forced to SA because it is in VHDL hierarchy"
  HDLFRC  // "Module '%s' cannot be forced to HDL-ICE because a module under its hierarchy was directed to sa bin"
  SPDVHD  // "Module 'SPDclkgen2' is found beneath VHDL"
  NODLPD  // "Interface signal '%s' between NC and Palladium has no driver or load in the palladium"
  NNSNMD  // "Non-synthesizable module/DU '%s' encountered in DUV"
  FCDTOP  // "The synthesizable module/DU top '%s' is forced to NC (simulator) bin"
  FRCDUV  // "The synthesizable module/DU under DUV top '%s' is forced to NC (simulator) bin"
  PGMIGR  // "Statements from lines %d to %d, in the source file \"%s\", are under \"synthesis_off/on\" pragma. The semantics of the design may differ from simulation semantics"
  PGMTSO  // "Basetype/subtype of \"%s\" has declaration under \"synthesis_off/on\" pragma"
  PGMUSO  // "\"%s\" has declaration under \"synthesis_off/on\" pragma"
  CONSTD   // "Delay is not a constant expression"
  DLNBLK   // "Delay in non-blocking assignment; delay will be ignored"
  IGNDLY  // "Lumped delay in module '%s' ignored"
  SYNTXZ   // "Synthesizing 'x'/'z' values in %s '%s'"
  XZDVAL   // "Delay value contains an x/z"
  METACX   // "In module '%s', case/casez item expressions evaluating to 'x' are ignored"
  METACZ   // "In module '%s', case item expressions evaluating to 'z' are ignored"
  METACO   // "In module '%s', conditional expression containing 'x'/'z' is statically evaluated to false"
  CASEZX   // "Case item expression contains 'x' for a casez statement (useful only in casex statements) in module/design-unit %s"
  V2CONF   // "Configuration file '%s' found for module '%s' is not supported by HDL-ICE, the RTL compiler of Palladium"
  VHDOMR   // "The OOMR '%s' pass through VHDL instance '%s'"
  TESDLY   // "Module '%s' contains delay statement in initial block. '%s' might be a part of testbench"
  DIFBIN   // "The file '%s' comprises of modules/UDPs which are partitioned in different bins"

  // Checks which reports problems in the command-line or the input file

  MISTOP  // "Design top not specified on the command-line for performing Acceleration Policy checks"
  NOEXMT  // "%s '%s' specified in the input file '%s' does not exist"
  NONBIN  // "%s '%s' specified in the input file '%s' is directed to a non-existing  bin '%s'"
  MISFLD  // "The '%s' field is missing for the %s '%s' in the input file '%s'"
  EXTCHR  // "Extra characters found for %s '%s' at the end of the line in input file '%s'"
  VHDLSA  // "The VHDL design-unit '%s' has been forced to Palladium simulation acceleration compiler (sa) in input file '%s'"
  MULENT  // "Multiple entries for redirection are found for %s '%s' in the input file '%s'"
  MULOPT  // "The option %s has been specified multiple times on the command line. Only the first %d specification(s) will be considered"
  MUINSD // "There are multiple instances of the same module/DU '%s' functioning as the design top"
  SHRVNS  // "Shared variables are not synthesizable"
  SHVUNS  // "In design-unit %s, use of shared variables is not synthesizable" 

  PD_NONSYNTH
  HDLICE_NOSUPP
  RTL_SIMRACE_VERILOG
}  



// ALL_TOOL does not have any sub-category
category ALL_TOOL "HAL usage errors" default_on
{
  //* Important - Most of the checks in this category are 
  //* NOT-SUPPRESSIBLE
  SYSTMC   // "Design contains SystemC(r) objects. HAL performs only linting checks on SystemC(r) objects"
  DEPSYS   // "Lint checking on SystemC objects has been deprecated and will not be supported in a future release"
  CMDNIM   // "%s is not yet implemented"
  BADDEF   // "%s"
  BADINF   // "%s"
  DEPINF   // "%s"
  BADARG   // "Incorrect argument '%s' specified with command line option '%s'"
  BADINP   // "Invalid input provided to HAL"
  NOCARG   // "%s"
  ONPARM   // "%s"
  LDFAIL   // "Unable to load dynamic library %s:\n%s"
  LDLOOK   // "Unable to locate startup routines in %s:\n%s"
  BBFAIL   // "Unable to write to %s"
  FILOPE   // "Unable to open \"%s\" for %s"
  BADTOP   // "Unable to locate instance '%s' (specified by -TOP) in the design. This -TOP option will be ignored"
  NOTCMP   // "Scope specified by -TOP '%s' is not a component instance"
  TOOMNC   // "More than one cell specified"
  BDARGF   // "Command-line argument file '%s' could not be opened for reading (%s)"
  MISSCL   // "Missing cell name for the build process"
  NOSNAP   // "Snapshot '%s' does not exist in the libraries"
  NOWORK   // "%s work library not found/defined"
  PRTSNP   // "Snapshot '%s' is a partially elaborated design. Partially elaborated designs are not supported in HAL"
  NOLICI   // "License initialization failed"
  NOLICN   // "Unable to check out license for %s (%s). Run 'lic_error %d' for details"
  NAHLIC   //	"Unable to check-out license for %s (%s). Run 'lic_error %d' for details"
  PRLICF   //	"Licensing criteria is not met for tool to run in parallel"
  REARGF   // "Command-line argument file '%s' included more than once"
  DUPARG   // "Snapshot name provided by both ncverilog and the command-line. The snapshot name provided by command-line will be ignored"
  NOARGX   // "Missing command-line argument file after -FILE option"
  BADCAT   // "Category name '%s' is not recognized"
  REGEXB   // "The naming convention pattern %s is not a legal regular expression"
  NOREGX   // "The pattern parameter for message %s is null. Any name will match"
  BADRNG   // "%s: ERROR -- range could not be determined..."
  BADNAM   // "%s: ERROR -- unsupported type '%s'"
  BDDUSP   // "Badly formed design-unit specification %s"
  NLVSUF   // "The hdl.var variable VERILOG_SUFFIX is defined, but is not a list"
  NOTEMP   // "Cannot open/create temporary file '%s' for writing"
  CSTUDS   // "Stack size has been limited"
  NOROOT   // "Unable to locate Cadence installation root directory"
  NOHDLF   // "No valid HDL source files provided"
  GNSENF   // "Genus executable not found"
  CNOTPR   // "%s in file '%s' has multi-line comment, which does not end anywhere"
  COFILE   // "Cannot open source file '%s'"
  MISAGO   // "A '%s' option was found without an argument and will be ignored"
  NOSUPP   // "HAL does not work in combination with 64-bit NC binaries"
  OBSOPT   // "Option '%s' has become obsolete. Use option '%s' instead"
  OPTIGN   // "Option '%s' is no longer required/supported, and will be ignored"

  UODIFW   // "Unable to open design info file '%s' for writing"
  BLKERR   // "Blackbox unit %s is not present in the design"
  MEMERR   // "Memory Cell '%s' is not present in the design"
  DUTERR   // "%s '%s' is not present in the design"
  LNTERR   // "Design unit/file '%s' specified with lint pragma is not present in the design"
  NORUCY   // "The argument '%s' in lint pragma attached to the above line, does not map to any rule or category"
  PROTEC   // "Protected design-unit '%s' encountered in the hierarchy and will not be processed by the tool"
  PLSNAP   // "Snapshot '%s' does not exist (platform mismatch), rebuild"
  RVSNAP   // "Snapshot '%s' does not exist (version mismatch), rebuild"
  SSNFND   // "Snapshot '%s' does not exist in the libraries"
  SSNTRD   // "%s not read"
  MULTOP   // "The snapshot contains multiple top-level modules. Use the -TOP option to specify the hierarchy to be processed"
  AORAGG   // "Array of record aggregates are not currently supported for arrays of unconstrained types. Remodel the design"
  AORCON   // "Array of record created using concatenation of arrays of records is not supported. Remodel the design"
  BADDEF   // "Error reading message definitions file : %s"
  BLKPAT   // "Unsupported regular expression %s specified in blackbox file %s"
  DOMRNS   // "Disable OOMR not supported"
  GBXERR   // "Glassbox unit %s is not present in the design"
  IGNASR   // "Expression creation error. The assertion/sequence/group in the module/design-unit %s will be ignored"
  IMPFNS   // "Impure functions are not supported. The keyword impure will be ignored and the function will be treated as a pure function"
  INVASP   // "Ignoring invalid enum encoding specification"
  INVCON   // "Invalid concatenation count. Ignoring the expression with this count"
  MOMRNS   // "OOMR assignment to Verilog memory not supported"
  NCDRNG   // "In design-unit %s, unsupported non-constant discrete range is encountered"
  NMDINS   // "Unable to find module for instance %s"
  NOBBFL   // "Unable to open explicitly specified blackbox file for reading: %s"
  NOGBFL   // "Unable to open explicitly specified glassbox file for reading: %s"
  NOCACC   // "Design not compiled with connectivity access information. Pass -access +C flag to ncelab"
  NOFILO   // "Unable to open file for writing %s"
  NOIDEN  // "Parameter %s of subprogram call is not an identifier"
  NOPATT   // "Pre-defined attribute %s in design-unit %s is not synthesizable"
  NULRGW   // "In design-unit/module %s, node %s has a null range defined. This node is being turned to dummy node because this design-unit/module is explicitly blackboxed"
  NULSTR   // "Null strings are not supported"
  PERCIN   // "The tool has encountered error(s) while processing instance %s. This instance will be ignored"
  RNGEXP   // "Type range has unsupported expressions. Only static constant expressions are allowed in the range"
  SHVUNS   // "In design-unit %s, use of shared variables is not synthesizable"
  SOMRNE   // "OOMR subprogram (function/task) call is not supported"
  SOMRNF   // "OOMR subprogram (function/task) call is not supported"
  TOPERR   // "The specified top-level instance: %s, is not present in the design"
  TOUTDE   // "Design timed out after %s seconds"
  SUDPNS   // "Modeling style of sequential UDP in module %s is not supported"
  UNHNDL   // "Unhandled case in module/design-unit %s"
  UNKCIN   // "Unknown VHDL component instance %s"
  UNCINW   // "Unknown VHDL component instance %s"
  UNKGEN   // "Design-unit/Module %s has Generic/Parameter of unsupported type"
  UNKLNG   // "%s : Unknown language"
  UNKPEX   // "addVerilogPortExpr : Unknown Port Expression %s"
  UNKWND   // "findFormalType : Unknown node %s"
  UNSOMR   // "OOMR on unsupported construct"
  UNSOPR   // "Unsupported operator encountered %s. This expression will be ignored"
  UNSUPF   // "An internal error occurred (may be due to an unsupported feature/function/operator): %s : %s"
  UNSVLG   // "Unsupported Verilog 2001 feature: %s"
  USDUNT   // "Unsupported design-unit %s encountered"
  USFDEC   // "findFormalDecl: Unsupported call %s"
  USFENA   // "Unsupported formal expression in named association"
  USRATR   // "User-defined attribute in design-unit %s is not synthesizable"
  USRECR   // "Recursive records are not supported"
  USTCOV   // "In design-unit %s, type conversion %s is not supported"
  UUSCON   // "Unsupported declaration/construct used. Cannot proceed further: %s"
  UUSTYP   // "In design-unit %s, use of \"%s\" type is not synthesizable"
  WAVFRM   // "Multiple waveform elements not supported. Existing in %s %s, node %s"
  UNOMSU   // "OOMR on function/task %s using nodes outside the subprogram scope is not supported"
  IGNCIN   // "In %s %s, initialization to node %s is ignored"
  CEVTNS   // "Event on complex expression not supported. Complex expression %s in the event expression is replaced by %s, which is assigned the original complex expression"
  IGNCON   // "Due to the above-mentioned error/warning, the design construct ( %s ) in which this error occurred will be ignored"
  IGNULL   // "Null range expressions present in both LHS and RHS of assignment. The assignment will be ignored"
  FMLPDR   // "Due to the above-mentioned error the formal port list of design-unit/subprogram is being dropped"
  NOSUBP   // "Subprogram body not found"
  USENAR   // "Array types using encoded enumeration type to specify range bounds are unsupported"
  USENRG   // "Nodes of composite data types, having encoded enumeration type in array ranges is currently not supported"
  VHDRCE   // "HAL category RACES is not supported for VHDL design. This category is being ignored"
  BLDSTP   // "Further processing stopped because of synthesizability errors"
  UNOPNF   // "Unable to open %s file '%s'"
  PGMSSO   // "The subprogram body of \"%s\" is under \"synthesis_off/on\" pragma"
  MULOPT  // "The option %s has been specified multiple times on the command line. Only the first %d specification(s) will be considered"
  USENAR  // "Array types using encoded enumeration type to specify range bounds are unsupported"
  USENRG  // "Nodes of composite data types, having encoded enumeration type in array ranges is currently not supported"
  IPROTC  // "Design contains protected HDL code. This tool does not analyze designs having protected HDL"
  PROTCT  // "Ignoring instance '%s' as its module/design-unit is protected"
  TOPROE  // "Design will not be analyzed because top-level module/design-unit is completely protected"
  NOSTAN  // "For the specified FSM, the tool cannot perform analysis to determine terminal and unreachable states because of the large state space defined by the state register"
  MIXGEN  // "HAL does not support VHDL instantiation in a Verilog for-generate loop"
  UNSV2K  // "The Verilog-2001 construct '%s' is not supported by the tool"
  SYSMOR  // "Processing stopped because virtual memory limit exceeded"
  HALSIG  // "Unable to proceed further due to a critical error. Contact Cadence Design Systems for resolution to this problem"
  CFESIG  // "Unable to proceed further due to a critical error while processing %s '%s'. Contact Cadence Design Systems for resolution to this problem"
  SCPNFD  // "Scope '%s' not found"
  PINNFD  // "Pin '%s' not found in scope '%s'"
  MISVAL  // "%s value not specified or is incorrect for pin '%s' in '%s'"
  NCDOMN  // "Pin '%s' has '%s' specified as clock domain, but it is not specified as a clock or test clock"
  NOTSMD  // "In scope '%s', pin '%s' set as 'logic_dbist', but not as test_mode pin"
  LOOPSZ   // "Loop has more than %d iterations. Processing of loop may take some time, kindly wait"
  VLGMEM   // "Module %s has Verilog memories. For large memories, processing may take some time"
  DISCAT   // "The category '%s' in lint pragma attached to the above line, is disabled, which was earlier enabled"
  DISRUL   // "The rule '%s' in lint pragma attached to the above line, is disabled, which was earlier enabled"
  ENARUL   // "The rule '%s' in lint pragma attached to the above line, is enabled, which was earlier disabled"
  ENACAT   // "The category '%s' in lint pragma attached to the above line, is enabled, which was earlier disabled"
  NOCELL   // "Cell corresponding to module '%s' is not found in synthesis library"
  UNLLIB   // "Unable to load synthesis library '%s'"
  NOPORT   // "No port is found in the design for pin '%s' in cell '%s' in synthesis library '%s'"
  NOPINL   // "No pin is found in synthesis library '%s' for port '%s' of module/design-unit '%s'"
  NOCONW   // "'%s' condition is not found for flip-flop/latch in the cell '%s' in synthesis library '%s'"
  NOCONF   // "'%s' condition is not found for flip-flop/latch in the cell '%s' in synthesis library '%s'"
  UNSUOP   // "Unable to determine the operator type in expression '%s' in cell '%s' in synthesis library '%s'"
  MAPLIB   // "'%s' '%s' is mapped from library '%s'"
  FORGEN   // "The instances in the given for-generate block will be unrolled %d times. Such processing takes time, kindly wait"
  GLSBOX   // "%s %s automatically glassboxed"
  RULREP   // "%s rule has been checked on design '%s.%s:%s'
  SENNOT   // "Test mode checks will not be performed as scan enable pin is not present in the design info file"
  UNKNRL   // "Rule/message tag '%s' is not known to hal.
  STPUNK   // "Definition file contains unknown rules. Either remove these rules or set parameter 'allow_only_hal_and_custom_rules' to 'no'.
  SYSIGN   // "SystemVerilog '%s' construct is not supported by the tool. This will be ignored"
  SYSVIG   // "SystemVerilog '%s' construct is not supported by the tool. This will be ignored"
  CLKBKW   // "The support to SystemVerilog clocking construct is limited to default clocking and only applicable to SystemVerilog assertions. Any other usage of system verilog clocking construct is not supported by the tool"
  CLKBKE   // "The SystemVerilog clocking construct is not supported by the tool in this context. This will be ignored"
  SYSVPS   // "SystemVerilog construct: '%s' is not fully supported by HAL"
  BGOLAP   // "Design-unit/Module '%s' specified for blackboxing overlaps with design-unit/module '%s' specified for glassboxing"
  LPNOFL   // "lps_cpf option is not specified lps_verbose will be ignored"
  MAXWRN   // "Maximum warning count reached (%d). All further warnings will be ignored"
  MULCRF   // "Multiple conflicting filters specified for the rule '%s' in the design file '%s'"
  C1TO1R  {level=0}  //CPI Warning : Wrong One-To-One relationship for %s
  C1TOMR  {level=0}  //CPI Warning : Inappropriate One-To-Many relationship for %s
  CINTPR  {level=0}  //CPI Warning : Wrong integral property for %s
  CSTRPR  {level=0}  //CPI Warning : Wrong string property for %s
  CNULLP  {level=0}  //CPI Warning : NULL %s passed to %s
  COBJTP  {level=0}  //CPI Warning : Inappropriate object type %d for %s
  CBDFMT  {level=0}  //CPI Warning : Inappropriate format for %s
  CNONAM  {level=0}  //CPI Warning : Name %s not found
  CINTVR  {level=0}  //CPI Warning : Integer value range expected
  CENMVR  {level=0}  //CPI Warning : Enum value range expected
  CDNXST  {level=0}  //CPI Warning : %s %s does not exist
  CSUPMD  {level=0}  //CPI Warning : Mode %s not supported
  CDESNP  {level=0}  //CPI Warning : For design lib/cell/view need to be specified where lib/view are optinal
  CINTOF  {level=0}  //CPI Warning : While accessing %s, actual value wider than integer
  CAMNME  {level=0}  //CPI Warning : The specified design unit : %s is ambiguous. It matches all the following designs: %s
  CIFVER  {level=0}  //CPI Error : Incorrect intermediate file version
  CIFLIC  {level=0}  //CPI Error : License initialization failed
  CIFTRN  {level=0}  //CPI Error : Intermediate file seems to be truncated
  CRELUN  {level=0}  //CPI Error : Unknown object type in relocation %d
  CWQHUN  {level=0}  //CPI ERROR : Wrong query in UNIQUE mode for cpi_handle_by_name(), either too deep a search specified or querying from instance handle %s
  CLAERR  {level=0}  //%s %s
  ADCWOF  {level=0}  // "Missing -ADVANCE_DFT option with the Advance DFT check"
  TAWOAD  {level=0}  // "Missing -ADVANCE_DFT option for performing testability analysis"
}


category RMM "All checks complying to Reuse Methodology Manual" default_on
{
  CMBPAU {level=0}  // "Combinational loop detected through '%s' in module/design-unit '%s'"
  ASNCFL {level=0}  // "Asynchronous feedback loop detected through set/reset of flip-flop(s) and '%s' in module/design-unit '%s'"
  GTDCLK {level=0}  // "Clock gating detected for clock '%s' of flip-flop '%s'"
  ACNCPI {level=0} // "Asynchronous %s '%s' of latch/flip-flop '%s' is not controllable from primary inputs"
  LATINF {level=0}  // "Latch inferred for '%s'"
  MULMCK {level=1}  // "Multiple master clocks found. Clock '%s' for flip-flop '%s' is derived from master input '%s', while the previously detected clocks were derived from '%s' for flip-flop '%s'"
  MRSTDT {level=1}  // "Mix of synchronous and asynchronous set/reset found. Synchronous set/reset detected in '%s' and asynchronous set/reset detected in '%s'"
  TPOUNR {level=1}  // "Output '%s' of top-level module is not a register"
  MISSEL {level=1}  // "%s signal '%s' missing from sensitivity list of a sequential process/block"
  USESEL {level=1}  // "Signal '%s' should not be used in the sensitivity list of a sequential process/block"
  CBYNAM {level=1} // "Port connections should be made by name rather than position"
  NOTECH {level=1}  // "Instance '%s' is instantiating a technology cell. Avoid using technology cells in the design"
  //mcj ATLGLC {level=1} // "Glue logic inferred in top-level module/design-unit '%s'"
  //mcj DIFCLK {level=2}  // "Clock '%s' is being renamed to '%s'"
  DIFRST {level=2}  // "Set/Reset '%s' is being renamed to '%s'"
  VERCAS {level=2}  // "Identifier, label, instance, or module name '%s' reused with just case difference" 
  DIRRNG {level=2}  // "Inconsistent ordering of bits in range declarations in module/design-unit %s"
  //mcj KYEDIF {level=2}  // "EDIF reserved word '%s' used as an identifier or label"
  TSBINF {level=3} // "Signal '%s' defined in module/design-unit '%s', is inferred as a tri-state buffer"
  STYVAL {level=3}  // "Numeric value '%d' used for identifier '%s'. Use constants to avoid portability issues"
  STYBLK {level=3}  // "Block statement used. This will create portability issues"
  VHDREP {level=3}  // "Repeated usage of identifier or label name '%s'"
  VERREP {level=3}  // "Repeated usage of identifier or label name '%s'"
  MULTMF {level=3}  // "More than one module definition in file '%s'"
  //mcj KEYWOD {level=3}  // "VHDL reserved word '%s' used as an identifier or label"
  KVHWOD {level=3}  // "Verilog reserved word '%s' used as an identifier or label"
  STYSUL {level=3}  // "Type std_ulogic used for identifier '%s'. Use std_logic to avoid portability issues"
  STYSUV {level=3}  // "Type std_ulogic vector used for identifier '%s'. Use std_logic_vector to avoid portability issues"
  STYBIT {level=3}  // "Type bit used for identifier '%s'. Use std_logic to avoid portability issues"
  STYBTV {level=3}  // "Type bit_vector used for identifier '%s'. Use std_logic_vector to avoid portability issues"
  //mcj CKEYWD {level=3}  // "C/C++ reserved word '%s' used as an identifier or label"
  SYNSCU {level=3} // "Embedded synthesis script used in the design"
  //mcj UPCLBL {level=4}  // "Label '%s' should be written in uppercase"
  DIFFMN {level=4}  // "%s name '%s' differs from file name '%s'"
  NOBLKN {level=4}  // "Each block should be labeled with a meaningful name"
  //mcj SEPLIN {level=4}  // "Use a separate line for each HDL statement"
  NOINSN {level=4}  // "Each module/gate/primitive instance should be labeled with a meaningful name"
  //mcj LCVARN {level=4}  // "Uppercase characters used for identifier '%s'. Use lowercase characters for all signal names, variable names, and port names"
  //mcj UCCONN {level=4}  // "Lowercase characters used for identifier '%s'. Use uppercase characters for names of constants and user-defined types"
}


category LOW_POWER "All checks related to low power design" default_off
{
  CMBPAU {level=0}  // "Combinational loop detected through '%s' in module/design-unit '%s'"
  SRENSL {level=0}  // "The state retention element/cell '%s' is not inferred as sequential logic. It is %s"
  SRPDDC {level=1}  // "Retention flops in the power domain '%s' are controlled by different '%s'"
  ISPDDC {level=1}  // "Isolation rules from power domain '%s' are controlled by different control pins"
  LPISCS {level=1}  // "The signal controlling isolation cell isolating pin '%s' is not an output of a module or primary input"
  LPSRCS {level=1}  // "The %s  edge signal of  '%s' is not an output of a module or  primary input"
  ZDLOOP {level=1}  // "Non-constant delay '%s' in module/design-unit '%s' found in switchable power domain instance '%s'"
  INTCON {level=1}  // "VHDL signal '%s' of type integer in design-unit '%s' found in switchable power domain instance '%s' is not constrained"
  INISPD {level=2}  // "Initial block in module '%s' found in switchable power domain instance '%s'"
  RELSPD {level=2}  // "Real variable '%s' in module/design-unit '%s' found in switchable power domain instance '%s'"
  TIMSPD {level=2}  // "Time variable '%s' in module/design-unit '%s' found in switchable power domain instance '%s'"
  INLSPD {level=2}  // "Initial block with events/forever loops in module '%s' found in switchable power domain instance '%s'"
  ENMSPD {level=2}  // "Enumerated type '%s' in module/design-unit '%s' found in switchable power domain instance '%s'"
  INTEGD {level=2}  // "Delay expression in module/design-unit %s is not an integer"
  XZDVAL {level=2}  // "Delay value contains an x/z"
  CNVINT {level=2}  // "VHDL function CONV_INTEGER in design-unit '%s' found in switchable power domain instance '%s'"
  VARDLY {level=2}  // "Variable '%s' used as delay in module/design-unit '%s' found in switchable power domain instances '%s'"
  DLYINI {level=2}  // "Delay found in initial block in switchable power domain instance '%s'"
  LATMLG {level=2}  // "The latches '%s' in the process/always block are mixed with combinational logic"
  LPRACE {level=2}  // "Variable '%s' found in switchable power domain instance '%s' may cause race condition at power on"
  PROSPD {level=2}  // "Protected design-unit '%s' found in switchable power domain instance '%s'"
  UPTNCS {level=2}  // "The top-level power supply port '%s' is not connected to a $supply_on system task"
  UNMGEN {level=2}  // "Unnamed generate block found in module '%s'"
  BUFSPD {level=2}  // "Buffer cell in input path '%s' found in switchable power domain instance '%s'"
}

category RTL_SIMPERF "Category of all the simulation performance checks" default_off
{
  BLKSQB {level=1}  // "Blocking assignment encountered in a sequential block"
  NBCOMB {level=1}  // "Non-blocking assignment encountered in a combinational block"
  BLNBLK {level=1}  // "Signal '%s' is assigned via both blocking and non-blocking assignments"
  CDEFNC {level=1}  // "Case statement %s" 
  AVDREC {level=2}  // "Function '%s' is called recursively in %s '%s'" 
  LARGEN {level=2}  // "Large/nested generate statement with %s found in module '%s', exceeds the limit '%d'"
  LARFOR {level=2}  // "Large/nested for statement with %s found in module '%s', exceeds the limit '%d'"
  LARMEM {level=2}  // "Large memory '%s' with size '%d' found in module '%s', exceeds the limit '%d'"
  LNSENS {level=2}  // "Long sensitivity list with '%d' objects in module '%s' exceeds limit '%d'"
  MULTWT {level=2}  // "Multiple wait statements with count '%d' used in process block"
  OVCOND {level=2}  // "Long overlapping static condition '%s' found in assertion property '%s'"
  TRGGLT {level=2}  // "Variable '%s' with always blocks waiting on it is assigned multiple times with different values in a block"
  TSKAWS {level=2}  // "Task '%s' used in an always block"
}

//***************************************************************************
//**    This section consists of all the e-language related checks         **
//***************************************************************************

category ALL_E "This category consists of all the categories for e Linting" default_off
{
  E_TOOL          // Tool messages for e Linter
  E_LINT          // Category of all the Lint level checks
  UVM_E           // Category of all the UVM checks
  E_PERFORMANCE   // Category of all the Performance level checks
  E_COVERAGE      // Category of all the Coverage level checks
  E_STYLE         // Category of all the Style checks
  E_GENERATION    // Category of the Generation checks
}

category E_TOOL "Tool messages for e Linter" default_off
{
  EAMISI  // HAL cant issue messages on (some) compiled files, for example %s, because they were compiled without -lint_mode
  EANUMP  // HAL parameter '%s'%s is expected to be a number, but is defined as '%s' in the rule file
}

category E_LINT "Category of all the Lint level checks" default_off
{
  EAILTC  // An infinite loop is detected
  EAVOCO  // Value of option '%s' in a predefined configuration routine was overwritten. New value is '%s', while old value is '%s' %s
  EARITN  // Reference to '%s' is seen in a nested construct which is enclosed by '%s' creating inner and outer constructs. Inner construct is %s, while outer construct is %s
  EATDSF  // Implicit enumerated type declaration
  EATRNG  // %s is not a valid range for '%s', and is automatically reduced to %s
  EATSIZ  // The range for '%s' is automatically reduced from %s to %s
  EAROSU  // Relational operator comparing %s with %s
  EAUNTF  // A field of type '%s' is declared
  EAVFNM  // Variable '%s' has same name as that of a field of a struct declared in %s
  EASVHV  // Variable '%s' declaration hides a variable in upper block with same name, declared in %s
  EAEMIO  // The 'is only' extension overrides a previous definition of method '%s' in '%s'
  EAFSCS  // Case action was not fully specified. The following labels are missing: %s
  EANCSH  // No context specified for size of HDL object %s; assuming 32 bits
  EAHPHS  // Hierarchical path of HDL signal found: %s, consider using hdl_path() method of an unit construct
  EAVDNN  // Variable '%s' is declared but not used
  EAVDNA  // Variable '%s' is written %s but not read
  EAVDUN  // Variable '%s' is read %s but not written
  EAOUTP  // '%s' used not inside a 'dut_error' or 'message(f)'
  EASGPT  // A %s access expression used not in the context of '%s'
  EAUNRE  // The code is unreachable
  EAMTOV  // Method extension %s.%s() overrides a previous layer
  EAGLOV  // Pre-defined method %s.%s() is overwritten
  EAHDNM  // The name '%s', beginning with an underscore, should not be used
}

category UVM_E "Category of all the UVM checks" default_off
{
  ERPKCT  // Configuration template file missing at %s
  ERPKDN  // The #define name %s is not prefixed with the package name '%s'
  ERPKDS  // The demo.sh file was not found at %s
  ERPKEE  // Extended enum value '%s' is not prefixed with the package name '%s'
  ERPKEN  // No 'e' package is defined in the module
  ERPKFN  // File name %s is not prefixed with the package name '%s'
  ERPKIM  // The 'import' statement refers to an absolute path
  ERPKLN  // Illegal UVM e package name: %s
  ERPKMP  // UVM e package prefix '%s' is missing from the 'e' package name '%s'
  ERPKPN  // The top file belongs to 'e' package '%s', which is not identical to the UVM e package name: %s
  ERPKPR  // There are %d public %s and %d non-public %s in the package '%s'
  ERPKTE  // '%s' is not prefixed with the package name '%s'
  ERPKTP  // Top file %s is missing in the e UVC
  ERPKTC  // Top file contains statements other than 'import' and '#define'
  ERPKVD  // '%s' subdirectory missing from %s
  ERPKVN  // The top file does not contain a version definition %s
  ERPKRV  // Package version number is missing
  ERARAA  // Agent '%s' does not contain a BFM
  ERARAC  // Agent %s does not contain a 'name' field
  ERARBF  // BFM %s is not instantiated within an ACTIVE agent
  ERARIN  // Agent %s is not instantiated within env or another agent
  ERARMN  // Monitor %s is not instantiated within env, agent, or another monitor
  ERARNM  // The env unit does not contain a 'name' field
  ERARSA  // BFM sequence driver %s is not instantiated within an ACTIVE agent
  ERARSD  // Agent '%s' does not have a BFM sequence driver
  ERARSG  // External %s port is not instantiated within a signal_map
  ERARSM  // Signal map %s is not instantiated within an agent or 'env' unit
  UVARMN  // Monitor '%s' does not contain any out ports
  UVARTL  // Monitor '%s' does not contain any TLM ports
  ERCHCE  // There are %d %s in the package %s
  ERCHDE  // There are %d dut_errors in package %s
  ERCHDM  // Explicit error message missing in a %s
  ERCHEX  // '%s' is not named
  ERCVCG  // There are %d coverage groups in package %s
  ERCVCI  // There are %d coverage items in package %s
  ERCVCR  // There are %d coverage crosses in package %s
  ERSQPT  // Sequence '%s' has %d user-defined kind(s): %s
  ERSQRW  // %d sequence drivers have read() and write() methods extended in package %s
  ERSQSD  // Virtual sequence driver %s does not have subdrivers
  ERSQSS  // There are %d sequence drivers in package %s
  ERSQVP  // Virtual sequence driver %s has no pointers to other sequence drivers
  ERSQWR  // %d sequences implement read() and write() methods in package %s
  ERMSMA  // There are %d message actions in package %s
  ERMSMT  // %d message tags are defined in package %s%s
  ERMSSN  // %s has no short_name() defined
  ERDCDC  // No documentation found in %s
  ERDCRN  // No release notes found in %s
  ERGDCL  // The package %s contain %d lines of e code. There are %d lines in total, including comments
  UVBTNU  // The standard 'uvm_e' package is not used in package %s
  UVBTAG  // No uvm_agent unit found in package %s
  UVBTBF  // No uvm_bfm unit found in package %s
  UVBTCL  // No uvm_collector unit found in package %s
  UVBTEN  // No uvm_env unit found in package %s
  UVBTMN  // No uvm_monitor unit found in package %s
  UVBTSM  // No uvm_signal_map unit found in package %s
  UVTFRN  // Unit '%s' participates in the Testflow but its run() method is extended
  UVTFSQ  // The sequence driver '%s' participates in the Testflow but the body of the MAIN sequence is extended
}

category E_PERFORMANCE "Category of all the Performance level checks" default_off
{
  EAPROF  // An error occurred while reading profiler file
  EAOROF  // Cannot open profiler file: %s
  EALIAF  // Using '%s' on list items in a loop; consider using 'str_join()' instead. Iterative loop starts %s
  EALDIB  // Using list pseudo method 'delete(0)' from an iterative loop which starts %s
  EALPIB  // Using list pseudo method 'pop0' from an iterative loop which starts %s
  EALAIB  // Using list pseudo method 'add0' from an iterative loop which starts %s
  EADCOS  // Deep copy is done on a struct whose fields deep_copy attribute is 'normal'
  EAAPFD  // Field '%s' was declared for struct '%s' after many fields were declared for some of its subtypes%s
  EASTMA  // State machine action is being used.State machine action is not optimal in terms of performance, and hence its usage is being flagged
  EAEVNU  // Event '%s' is never used
}

category E_COVERAGE "Category of all the Coverage level checks" default_off
{
  EACEOP  // 'using' option '%s' conflicts with a previous definition at %s
  EACOBT  // Coverage group '%s' in like-inherited struct redefines same coverage group defined in the base struct (first definition is %s)
  EANEDR  // integer sub-ranges do not contain single value conditions
  EAUGIT  // An integer item %s has more distinct bucket values than max_int_buckets(=%d), but does not use ranges
}

category E_STYLE "Category of all the Style checks" default_off
{
  EAUNNM  // Unit name '%s' does not match the pattern '%s'
  EAEVNM  // Event name '%s' does not match the pattern '%s'
  EAMTNM  // Method name '%s' does not match the pattern '%s'
  EATENM  // Enumerated type name '%s' does not match the pattern '%s'
  EASTNM  // Struct name '%s' does not match the pattern '%s'
  EATSNM  // Scalar type name '%s' does not match the pattern '%s'
  EASQNM  // Sequence name '%s' does not match the pattern '%s'
  EAVRNM  // Variable name '%s' does not match the pattern '%s'
  EAMTMF  // Struct/unit '%s' contains more than %d fields. Total number of fields in the struct is %d
  EAMTMM  // Struct/unit '%s' contains more than %d methods. Total number of methods in the struct is %d
  EASDWS  // Struct name '%s' is without _s suffix
  EAUDWS  // Unit name '%s' is without _u suffix
  EAETWS  // Enumerated type name '%s' is without _t suffix
  EASTWS  // Scalar type name '%s' is without _t suffix
  EAEVWS  // Event name '%s' is without _e suffix
  EAMALF  // File size exceeds %d lines
  EAMALM  // The code size of a method layer exceeds %d lines
  EAMACL  // Line exceeds %d characters. Number of characters on the line is %d
  EANOCL  // The check %s cannot be performed on module @%s: the source file %s does not exist
}

category E_GENERATION "Category of the Generation checks" default_off
{
  EAGLIC  // Inconsistent Connection %s
  EAGNDX  // Constraint with generative paths which belong to different generative scopes. Use read_only to make it relevant to a single gen action, for example %s
  EAGNDG  // Do-not-generate field %s is constrained but not generated
  EAGNCF  // Above constraint on generative field
  EAGNII  // '%s' in the expression '%s' is supported as input only. It is recommended to wrap it with read_only()
  EAGLGA  // Accessing a global field %s during generation is not recommended
  EAGLGB  // Accessing a generatable me field %s in pre_generate() is not recommended
  EAGLGC  // Modifying a generatable me field %s in post_generate() is not recommended
  EAGLGD  // Accessing a generatable me field %s in methods called from constraints is not recommended
  EAGLGE  // Extending a method under a when subtype %s used in a constraint is not recommended
  EAGLGF  // List assignment path %s in the following constraint: %s
  EAGLGG  // Struct assignment path %s in the following constraint: %s
  EAGLGH  // The field <%s>.%s is constrained to be a pointer reference in the path %s. IntelliGen requires that reference pointer fields be constrained to another pointer in their declaring type. If you don't know the assigning %s, you can add the constraint 'keep soft %s == %s;' in type %s: 
  EAGLSA  // Soft constraint which is defined after previous selects: %s. Suggestion: move the soft constraint to precede any of the selects
  EAGLSB  // Non-unary soft constraint: %s. Suggestion: to make the constraint unary, wrap with read_only all the variables except the primary one
  EAGLSC  // Soft constraint with possible effect on other variables: %s
}

params EASGPT {struct_name="any_struct"}
params EAUNNM {pattern="..."}
params EAEVNM {pattern="..."}
params EAMTNM {pattern="..."}
params EATENM {pattern="..."}
params EASTNM {pattern="..."}
params EATSNM {pattern="..."}
params EASQNM {pattern="..."}
params EAVRNM {pattern="..."}
params EAMTMF {max="50"}
params EAMTMM {max="30"}
params EAMALF {max="1000"}
params EAMALM {max="50"}
params EAMACL {max="80"}
params EALIAF {profiler_dependent="yes"}
params EALDIB {profiler_dependent="yes"}
params EALPIB {profiler_dependent="yes"}
params EALAIB {profiler_dependent="yes"}
params EADCOS {profiler_dependent="yes"}
params HAL {e_macro_def_first="no"}
params HAL {e_profiler_threshold="0.1"}

//***************************************************************************
//**                   End of e-language related checks                    **
//***************************************************************************


//***************************************************************************
//**    Following is the description of the default HAL parameters         **
//***************************************************************************

// **********************
// Overall HAL parameters
// **********************

// **************************************************************************
// **                  print decoded name                                **
// **************************************************************************
// If a vector is partially used or assigned or unused then all such bits are
// consolidated and clubbed in one (wherever possible) while throwing the 
// message. For ex. reg [3:0]signal declared in design, if only signal[0] is used 
// then while throwing check URAREG (signal is unused), instead of 3 message
// each for signal[1], signal[2] and signal[3] only one message is thrown that 
// signal[3:1] is unused. So it reduces repetition of same kind of message.
// But if declared signal is struct/union and used partly then in that case 
// consolidated signal/variable name is difficult to decipher for ex.
// module top();
//  typedef struct packed {
//    reg [3:0] a;
//    reg [3:0]b;
//    reg c;
//    reg d;
//  } my_struct_t;
//
// my_struct_t my_struct;
// assign my_struct[3:2] = 0;
// endmodule
// In this example URDREG is thrown stating that 'my_struct[3:2]' is not read but assigned.
// But instead of 'my_struct[3:2]' if its decoded name 'my_struct.b[1:0]' is printed then 
// it would be easier to interpret and debug. This parameter controls this behavior.

//params HAL {print_decoded_name="yes"} 
params HAL {print_decoded_name="no"} 

// **************************************************************************
// **                  Wave-off in `include files                          **
// **************************************************************************
// If a check that is reported from "`include file" of a "design unit" and
// that check is waived-off from this design unit. Since the included file 
// is part of design unit so waiver constraints posed on this design unit 
// should reflect on included file as well for ex.
// module top;
// `include "func.v"
// endmodule
// there is a function definition in func.v in which URDREG is issued
// lint_checking designunit = top
// {
//   URDREG off;
// }
// Whether or not URDREG to issue in func.v is controlled by below parameter

//params HAL {apply_waiver_on_include_files="yes"} 
params HAL {apply_waiver_on_include_files="no"} 


// **********************************************************
// **       Parameter for accumulation of filters         **
// **********************************************************
// By default, on processing of design info file if same rule is found
// multiple times in the lint_checking filter list then
// last written rule filter is considered as the final filter.
// For example
// lint_checking file = top.v
// {
//   URAWIR {pattern="*_in"} off; // Not taken in consideration
//   URAWIR {pattern="*_out"} off;  // taken as the final filter
// }
// Here second occurrence is taken as final and wherever URAWIR rule
// has to be thrown, the variable/signal name is checked against "*_out" filter only.
// If param merge_design_info_lint_pragmas is set to 'yes' then both filters will be taken in consideration.

//params HAL {merge_design_info_lint_pragmas="yes"} 
params HAL {merge_design_info_lint_pragmas="no"} 


// **********************************************************
// **       Parameter for regular expression style         **
// **********************************************************
// Which style of regular expression is used for the "pattern" in the 
// naming convention rules?  Choices are "csh" (basic 'glob' 
// expressions) or "full" (full regular expressions as used in egrep, 
// perl and so on).  The "csh" style is the default, because it is simpler 
// and more familiar. 

params HAL {regex_style=csh} 
// params HAL {regex_style=full}


// ***********************************************************
// ** Parameter for Allowing/Disallowing severity downgrade **
// ***********************************************************
// By default, HAL does not allow message severity to be downgraded (for example
// by specifying a {warning} parameter for a message that was originally
// flagged as an ERROR).  This behavior can be changed by setting the
// 'severity_downgradable' parameter below to 'yes'.

params HAL   {severity_downgradable=no}
// params HAL {severity_downgradable=yes}


// ***********************************************************
// **     Parameter for controlling unclassified rules      **
// ***********************************************************
// By default, HAL does not report messages which are not mentioned in
// this file.  However, there are flows in which it would be preferable
// for unclassified messages to be reported. The parameter below can
// be used to change this default behavior.

params HAL {disable_unclassified_rules=yes}
//params HAL {disable_unclassified_rules=no}


// ***********************************************************
// **     Parameter for controlling error suppression       **
// ***********************************************************
// By default, HAL allows checks with severity error to be suppressed
// using -NOCHECK <check_name>/<category_name> command. However, if the
// requirement is such that the error severity checks are always flagged,
// the parameter below can be used to change the behavior.

params HAL   {allow_error_suppression=yes}
// params HAL {allow_error_suppression=no}


// ***************************************************************
// **  Parameter for controlling design_info error suppression  **
// ***************************************************************
// By default, HAL does not allow suppression of errors due to 
// incorrect specifications in design_info file. However, the 
// following parameter allows you to suppress errors such as 
// BLKERR, GBXERR, LNTERR, and DUTERR through various 
// suppression mechanisms available in HAL.
// The default value of this parameter is set to 'no'. 
// To suppress the errors, set the value of this parameter 
// to 'yes'.

params HAL{allow_design_info_error_suppression=no}
//params HAL{allow_design_info_error_suppression=yes}


// **************************************************************************
// **   Parameter for controlling suppression of synthesizability errors   **
// **************************************************************************
// By default, HAL does not allow synthesizability checks with original severity
// error to be suppressed using -NOCHECK <check_name>/<category_name> command. 
// However, if the requirement is such that the error severity synthesizability 
// checks should be suppressed, if the modules with synthesizability errors
// are automatically blackboxed by HAL using the -BB_NONSYNTH command, 
// the parameter below can be used to change the behavior.

params HAL {suppress_synthesizability_errors=no}
// params HAL   {suppress_synthesizability_errors=yes}


// ***********************************************************
// **     Parameter for displaying lint pragma control      **
// ***********************************************************
// If the lint pragmas are used in the design, then by default, the
// check/category control introduced using lint pragmas is not output
// in the hal.log file. In case, the information is required, the
// parameter below, can be used to display the information in the logfile.

params HAL {display_rule_control=no}
// params HAL {display_rule_control=yes}


// ***********************************************************
// **       Parameter for controlling the clock list        **
// ***********************************************************
// The following parameter controls how the -CLOCK_LIST option
// behaves for the structural checks. If params clock_list is
// set to 'APPEND', then the user specified list of clocks will
// be added to the list of clocks determined by the tool.
// If clock_list parameter is set to 'OVERWRITE', then the tool
// will only use the user specified list of clocks.
// If no clock_list parameter is found, then 'APPEND' mode is assumed.

params HAL {clock_list=APPEND}
//params HAL {clock_list=OVERWRITE}

// ***********************************************************
// **  Parameter for specifying Verilog comment style       **
// ***********************************************************
// The following parameter specifies the Verilog comment style
// to be used by the developer. Following styles are supported:
//     - single-line comments (// ... )
//     - multi-line comments  (/* ... */)
//     - none (no prescribed comment style)
// The tool will issue a check if the comments in code do not 
// match the prescribed coding style (or if style specified
// is "none".

//mcj params HAL {code_comment_style_verilog="single-line"}
//params HAL {code_comment_style_verilog="multi-line"}
params HAL {code_comment_style_verilog="none"} //mcj


// *************************************************************
// **  Parameter for specifying Header Field Separator    ******
// *************************************************************
// The following parameter specifies the field separator character
// which may be used by the user to delimit fields placed together 
// on the header line. Example:
//     Date     Version Author  Description
//     01/01/06 : 0.3 : user  : first version
// This parameter will be used by the tool for header data analysis.

params HAL {header_field_separator=":"}


// *************************************************************
// **  Parameter for specifying Header Section Separator    ****
// *************************************************************
// The following parameter specifies the section separator character
// which may be used by the user to delimit sections in the header.
// Example:
// Section A
// ------------------------------------------------------------
// In the above example, a line with the '-' character is used 
// to delimit the header section 'Section A' from the section
// following it.
// This parameter will be used by the tool for header data analysis.

params HAL {header_section_separator="-"}


// *************************************************************
// **  Parameter for specifying if Header is Case Sensitive  ***
// *************************************************************
// The following parameter specifies if the header information
// entered by the user will be validated (against the reference 
// information provided for the header in the hal.def file)
// in a case sensitive manner or not.

params HAL {header_case_sensitive="no"}


// ******************************************************************
// **  Parameter for Ignoring empty lines for Code Comment checks ***
// ******************************************************************
// The following parameter specifies whether empty lines are to be
// ignored for checks on comments in code. When set to "yes",
// if there is an empty/blank line before a code line on which 
// presence of comment is being checked, the blank line will be
// ignored and comment will be searched on the line preceding the
// blank line. When set to "no", comment will be searched only on
// the line preceding the code line, and not any lines above that.

params HAL {ignore_empty_line_for_comment="no"}
// params HAL {ignore_empty_line_for_comment="yes"}

// *******************************************************************
// ******** Parameter to control fsm encoding styles *****************
// *******************************************************************

//mcj params HAL {fsm_state_coding_style="gray"}
// params HAL {fsm_state_coding_style="one_hot"}
// params HAL {fsm_state_coding_style="one_hot:gray"}
params HAL {fsm_state_coding_style="none"} //mcj

// This parameter controls the behavior of ONHOEN and TRNMBT. When the value of parameter 
// is set to "gray", TRNMBT will be issued for state machines where gray encoding is not used. 
// By default the value of parameter will be "gray". When the value is set to "one_hot", ONHOEN 
// will be issued for state machines where one-hot encoding is not used. When the value is set to 
// "one_hot:gray", both ONHOEN and TRNMBT will be issued if any of the encoding style is not used. 
// When the value of parameter is set to "none", any encoding style is allowed and no check will be issued. 

// *******************************************************************
// ******** Parameter to control handling of partial design **********
// *******************************************************************


params HAL {include_partial_design="no"}
//params HAL {include_partial_design="yes"}

// This parameter controls the behavior of checks which are affected by partial design
// When HAL encounters a partial design, all the unbounded instances are ignored by it.
// This parameter makes HAL to analyze those unbounded instances by making some assumption.
// The most important assumption is the direction of the ports in an unbounded instance, which 
// is assumed to be INOUT, if HAL cannot determine their direction. The direction is determined
// by the fact if a known port is connected to a unbound instance, the direction of the unbounded 
// port is assumed to be that of known port.
// Currently this parameter is effective only on verilog design, for check UNDRIV, URAREG and UASWIR.

// ****************************
// Category specific parameters
// ****************************


// ***********************************************************
// ** Parameters for controlling the checks in the category **
// ** BEH_CODING_STYLE_VHDL and RTL_CODING_STYLE_VHDL       **
// ***********************************************************

// The checks in the category BEH_CODING_STYLE_VHDL and 
// RTL_CODING_STYLE_VHDL are sensitive to the architecture name
// in the design. By default, the checks in these categories are
// triggered when the architecture name complies to the naming 
// convention prescribed by RMM, to name architectures at different
// levels of abstraction, which is Behavioral and RTL. The below 
// parameters can be used to change the architecture naming pattern
// to which the checks in these two categories are sensitive.

params RTL_ARCHNM {pattern="^(RTL|STR)" text=""}
params BEH_ARCHNM {pattern="^(TB|SIM|BEH)" text=""}

// **************************************************************
// *********** Parameter for controlling NUMSUF *****************
// **************************************************************
// This parameter controls the behavior of NUMSUF. If the parameter
// "vector"only" is set to "no", NUMSUF will be reported for all
// identifiers. By default the value of parameter is "yes" and NUMSUF 
//will be reported only for vector identifiers. .

params NUMSUF {vector_only="yes"}

// *******************************************************
// ************Parameters for POIASG **********************
//********************************************************
// This parameter controls the behavior of POIASG.
// By default, no value is set for this parameter, and the check is reported
// whenever there is a possibility of an overflow in the case of addition,
// multiplication, or exponential operations.
// When the parameter is set to up_counter, the check is not reported
// for counter operations, such as "a = a + 1".
// When the parameter is set to increment, the check is not reported
// for increment operations, such as "a = b + 1".
// When the parameter is set to down_counter, the check is not
// reported for counter operations, such as "a = a - 1".
// When the parameter is set to decrement, the check is not reported
// for decrement operations, such as "a = b - 1".

//params POIASG {ignore_poiasg="up_counter:increment:down_counter:decrement"}
params POIASG {ignore_poiasg=""}

// This parameter controls the behavior of POIASG in case of subtraction operation.
// The default value of this parameter is "yes". When the value is set to "yes", the 
// check is not reported for subtraction operations. When the value is set to "no", 
// the check is reported for a potential overflow in the case of subtraction operations. 

params POIASG {ignore_poiasg_on_subtraction="yes"}

// *******************************************************
// ************Parameter for BITUNS **********************
// *******************************************************

// The "ignore_on_size" parameter controls the behavior of check BITUNS.
// By default, no value is specified for this parameter, and therefore, BITUNS is 
// reported on all constants.
// If a value is specified for this parameter, the check is ignored on constants with 
// value "0" and with size more than or equal to the value specified for this parameter. 
// For example, if the value of the parameter is set as "5", then the check is ignored 
// for "6'b000" because the value of the constant is "0"  and the size is more than the 
// parameters value.
// Note: If the value of the parameter is not set, the check is reported on "6'b000" as well. 
   
   params BITUNS {ignore_on_size=""}

// The "ignore_on_bit" parameter controls the behavior of check BITUNS.
// This parameter in combination with "ignore_on_size" is used to determine when to ignore
// the BITUNS check.
// By default, no value is specified for this parameter, and therefore, BITUNS is ignored
// on constants with value "0", if "ignore_on_size" parameter has been set.
// If the value of the parameter is specified, then check is ignored for constants only
// containing the values specified by the parameter. The valid values are {"1","0"}.
// Any combination of these value can be specified.
// If no value is specified for "ignore_on_size" then BITUNS is ignored for all constants
// For example, if the value of this parameter is set as "1" and value of parameter "ignore_on_size"
// is set as "5", then the check is ignored for "6'b111" because constant only contains "1" and
// size is more than the value specified by "ignore_on_size".
// If the value of this parameter is set as "1:0", then all constants containing only "1" or only
// "0" are ignored, there combinations are not ignored.
// Note: If no value for "ignore_on_size" is specified but a value of this parameter is specified
// then the value of "ignore_on_size" is assumed to be "0".
// Note: If value of parameter "ignore_on_size" was specified as "6", and value of this parameter 
// was not set, then the check is reported on 6'b1111.

// params BITUNS {ignore_on_bit="1"}
// params BITUNS {ignore_on_bit="0"}
// params BITUNS {ignore_on_bit="0:1"}
   params BITUNS {ignore_on_bit=""}

// *******************************************************
// ************Parameter for OPRNUM **********************
// *******************************************************

   params OPRNUM {check_range_parentheses="no"}
// The default value of this parameter is "no".
// When the value is set to "no", OPRNUM checks the number of operators (multiplication, 
// division, power, or modulus) per expression. For example, if the parameter is set to "no", 
// OPRNUM is reported for expression "a = (b * c) * d" because the number of multiplication 
// operators determined for the expression is two (parentheses ignored).

// When the value is set to "yes", OPRNUM checks the number of operators (multiplication, 
// division, power, or modulus) per parentheses. For example, if the parameter is set to "yes", 
// OPRNUM is not reported for expression "a = (b * c) * d" because the number of multiplication 
// operators determined for the expression is one (number of operators determined per parentheses).

//*******************************************************
//************Parameter for BADSYS **********************
//*******************************************************
// These parameters control the behavior of BADSYS. If the parameter
// "ignore_badsys_within_pragmas" is set to "yes", BADSYS will be ignored for system functions
// which are inside synthesis_on/off and translate_on/off pragmas. The default
// value of this parameter is "no". BADSYS will be ignored for the patterns which
// are specified in the "pattern" parameter. By default BADSYS will be reported
// for all system functions/tasks.

params BADSYS {pattern=""}
params BADSYS {ignore_badsys_within_pragmas="no"} 

// *******************************************************
// ************Parameter for USEPAR **********************
// *******************************************************
// This parameter controls the behavior of USEPAR. If the value of the
// parameter is set to "true",the usage of par_a in the following
// example is ignored and USEPAR is reported: 
// example:
//     parameter par_a = 0;
//     parameter par_b = par_a;
// By default, the value of the parameter is "false".

params USEPAR {ignore_param_usage="false"}

// *******************************************************
// ************Parameter for ONPNSG **********************
// *******************************************************
// This parameter controls the behavior of ONPNSG. If the value of
// the parameter is set to "no", one pin buses are checked on the 
// entire design. If set to "yes", it is checked only on the top
// module. The default value is set to "no".

params ONPNSG {top_only="no"}
//params ONPNSG {top_only="yes"}

//*******************************************************
//************Parameter for INDXOP **********************
//*******************************************************
// These parameters control the behavior of INDXOP. There are 3 cases for INDXOP.
// Case 1) Operation involving all constants. 
//         Here by default INDXOP will be "OFF". INDXOP will be reported for the 
//         operations mentioned in the parameter "report_operator_constant_operands". 
// Case 2) Operation involving 1 variable.
//         Here by default INDXOP will be "OFF" for "addition" and "subtraction".
//         For all other operations it will be "ON". INDXOP will be reported for
//         "addition" and "subtraction", if they are mentioned in the parameter
//         "report_operator_constant_variable_operands".
// Case 3) Operation involving 2 or more variables.
//         Here by default INDXOP will be reported for all operations. For the
//         operations mentioned in the parameter "ignore_operator_variable_operands", 
//         INDXOP will be ignored.

params INDXOP {report_operator_constant_operands=""}
params INDXOP {report_operator_constant_variable_operands=""}
params INDXOP {ignore_operator_variable_operands=""}

// List of operators
// addition, subtraction, multiplication, concatenation, replication, bit-wise and, 
// bit-wise inclusive or, bit-wise exclusive or, bit-wise equivalence, bit-wise negation
// logical equality, logical inequality, case equality, case inequality, binary greater than
// binary greater than or equal, binary less than, binary less than or equal
// modulus, unary minus, unary plus, logical negation, division, logical and, logical or 
// arithmetic left shift, arithmetic right shift, binary left shift, binary right shift, arithmetic power

//**********************************************************
//******************Parameter for REDOPR *******************
//**********************************************************
// This parameter controls the behavior of REDOPR. REDOPR is reported for
// reduction operation on a signal whose bit width is larger than the width
// specified in the parameter "size_operand". By default the value is "32".

 params REDOPR {size_operand=32}

// **********************************************************
// ******************Parameter for USEMAC *******************
// **********************************************************
// This parameter controls the behavior of USEMAC. If the value of
// parameter "check_include_file" is set to "yes", then USEMAC is reported
// for unused macros in include file also. By default the value is "no". 
 
params USEMAC {check_include_file="no"}

// **********************************************************
// ******************Parameter for NTACHR *******************
// **********************************************************
// This parameter controls the behavior of NTACHR. If the value of
// parameter "reserved_keyword_list_case_sensitive" is set to "no",
// then NTACHR will be reported for the identifier names mentioned
// in the reserved_keyword_list irrespective of the case. By default
// the value is yes.

params NTACHR {reserved_keyword_list_case_sensitive="yes"}

// ****************************
// Check specific parameters
// ****************************
params NTACHR {reserved_keyword_list=""}
params IDLENG {exception_list=""}
params SIGLEN {exception_list=""}
params MPCMPE {expression_complexity=5}

// ***********************************************************
// ** Parameter to disable TROPCC/TROPCZ on port declaration** 
// ***********************************************************

//This parameter controls the behavior of TROPCC/TROPCZ. If the value 
//of parameter is set to "yes", then tool will not check these warnings 
//on port declaration. By default value is "no"

params TROPCC:TROPCZ {disable_on_port_declaration="no"}


// ***********************************************************
// ** Parameter to disable MULCAS on 'Z' overlap** 
// ***********************************************************

//This parameter controls the behavior of MULCAS. If the value 
//of parameter is set to "yes", then tool with not check MULCAS 
//for z overlap.By default value is "no"

params MULCAS {ignore_z_overlap ="no"}

params MULCAS {ignore_within_list_overlap ="no"}
params MULCAS {ignore_overlap_except_unique ="no"}

// ***********************************************************
// **      Parameters to specify the naming convention      **
// ***********************************************************
params TBNNAM {pattern="*_tb"    text=": should end with '_tb'"}
params ALOWID {pattern="*_n"    text=": should end with '_n'"}
//params MODLNM {chip_pattern="^[a-zA-Z0-9_]{1,16}$" chip_text=""}
//params MODLNM {physical_level_pattern="^[a-zA-Z0-9_]{1,32}$" physical_level_text=""}
//params MODLNM {block_level_pattern="^[a-zA-Z0-9_]{1,217}$" block_level_text=""}
params MODLNM {default_pattern="*_mod"  default_text="should end with '_mod'"}
params SVIFNM {pattern="*_bus"  text=": should end with '_bus'"}
params INSTNM {pattern="*"      text=""}
//params INSTNM {pattern="^[a-zA-Z0-9_]{1,64}$"      text=""}
params BLKLNM {pattern="*_blk"  text=": should end with '_blk'"}
params FUNCNM {pattern="func*"  text=": should start with 'func'"}
params TASKNM {pattern="task*"  text=": should start with 'task'"}
params PARMNM {pattern="*"      text=""}
params INTGNM {pattern="*"      text=""}
params REALNM {pattern="*"      text=""}
params MEMRNM {pattern="*_mem"  text=": should end with '_mem'"}
params WIRENM {pattern="*"      text=""}
params REGRNM {pattern="*"      text=""}
params FFNAME {pattern="*"      text=""}
params ARCHNM {pattern="*_arch" text=": should end with '_arch'"}
params ENTYNM {pattern="*_ent"  text=": should end with '_ent'"}
params PCKGNM {pattern="*_pkg"  text=": should end with '_pkg'"}
params CMPPKG {pattern="*_cmp_pkg" text=": should end with '_cmp_pkg'"}
params SUBRNM {pattern="*_proc" text=": should end with '_proc'"}
params ACCSNM {pattern="*_P"    text=": should end with '_P'"}
params CNSTNM {pattern="*_C"    text=": should end with '_C'"}
params FILENM {pattern="*_F"    text=": should end with '_F'"}
params LIBRNM {pattern="*"      text=""}
params SIGLNM {pattern="*"      text=""}
params VARLNM {pattern="*"      text=""}
//params PORTNM {chip_pattern="^[a-zA-Z0-9_]{1,16}$" chip_text=""}
//params PORTNM {physical_level_pattern="^[a-zA-Z0-9_]{1,64}$" physical_level_text=""}
//params PORTNM {block_level_pattern="^[a-zA-Z0-9_]{1,256}$" block_level_text=""}
params PORTNM {default_pattern="*"      default_text=""}
params ALOWNM {pattern=".*(VSS|VDD|GND|VCC).*|.*(vss|vdd|gnd|vcc).*"  text="" local_regex_style="full"}
params OUTPNM {pattern="*_O"    text=": should end with '_O'"}
params INPTNM {pattern="*_I"    text=": should end with '_I'"}
params IOPTNM {pattern="*_IO"   text=": should end with '_IO'"}
params CLKSNM {pattern="*_CK"   text=": should end with '_CK'"}
params ASTMNM {pattern="^assert_.*$"  text=": should start with 'assert_'"}
params LOCVNM {pattern="^l_.*$"       text=": should start with 'l_'"}
params COVRNM {pattern="^cover_.*$"   text=": should start with 'cover_'"}
params ASUMNM {pattern="^assume_.*$"  text=": should start with 'assume_'"}
params SEQNNM {pattern="^s_.*$"       text=": should start with 's_'"}
params PROPNM {pattern="^p_.*$"       text=": should start with 'p_'"}
params RSTNAM {pattern="_rst$|^rst_|^rst$"   text=": should end with '_rst' or start with 'rst_' or just be 'rst'"  local_regex_style="full"}
params CONFNM {pattern="^$ENTNAME.*$"   text=": should start with the name of the entity to which configuration is bound"  local_regex_style="full"}
params VLFLNM {pattern="$MODNAME"}
params TBCHNM {pattern="$MODNAME"}

// This parameter is used to set the allowable character set.
params NTACHR {pattern="^([_]?([a-zA-Z0-9:]+_?[a-zA-Z0-9:]*)*)$" text="" local_regex_style="full"}

params UCOPNM {pattern="*_nc"     text=": should end with '_nc'"}
params RGOPNM {pattern="*_reg"    text=": should end with '_reg'"}
//params RGOPNM {named_block_register_pattern="^[a-zA-Z0-9_.]{1,60}$"    text=""}
params HIMPNM {pattern="*_z"      text=": should end with '_z'"}
params STMCNM {pattern="*_state"  text=": should end with '_state'"}
params LTCHNM {pattern="*_l"  text=": should end with '_l'"}
params TESTNM {pattern="*_test"     text=": should end with '_test'"}
params MULSNO {order=""} 
params DIFSIG {pattern="*"} 
params MACRNM {pattern="*"      text=""}


// ***********************************************************
// **   Parameters to specify the file format conventions   **
// ***********************************************************

params MAXPRT {max_ports=25}
params MLITNU {max_literals=20}
params SUBPLN {max_lines=300}
params MXPROC {max_processes=10}
params PBYNAM {num_params=5}
params FILSUF {pattern="(vhd$|vhdl$|v$|cpp$|cxx$|c++$|cc$|c$)" local_regex_style="full"}

params DESULN {max_lines=400}
params INSTLB {max_length=8}
params IDLENG {min_instance_length=4}
params IDLENG {max_instance_length=16}
params IDLENG {min_label_length=4}
params IDLENG {max_label_length=16}
params IDLENG {min_port_length=4}
params IDLENG {max_port_length=16}
params MAXLEN {max_line_length=80}
params SIGLEN {min_length=1 max_length=32}
params ARCHID {suffix_list="rtl|^rtl_|_rtl$|beh|^beh_|_beh$|syn|^syn_|_syn$|ppr|^ppr_|_ppr$|logic|^logic_|_logic$|hls|^hls_|_hls$|vit|^vit_|_vit$|tst|^tst_|_tst$" local_regex_style="full"}

// ***********************************************************
// **   Parameters to control reporting of COMEND check.   **
// ***********************************************************

// COMEND check is reported if the number of code lines between begin/end or
// case/endcase is greater than min_line_count parameter. By default, the "min_line_count"
// parameter is set to 0, so that COMEND check is reported irrespective of number of
// code lines between begin/end or case/endcase.

params COMEND {min_line_count=0}

// ***********************************************************
// ** Parameters to control the severity levels of checks   **
// ***********************************************************

params AWNDEL {error}
params WAITML {error}
params OUTRNG {error}
params TERMST {error}
params UNRCHS {error}
params TOPGEN {error}

// ***********************************************************
// ** Parameters to control the direction range for arrays  **
// ***********************************************************

// Default direction for range in array/vector declarations is "descending".
// This can be changed to "ascending", if that is preferred.  This
// only matters for the DIRRNG check, which is a part of part of the RMM
// guidelines as well as the RTL_FILEFORMAT_MIXED category in HAL.

params DIRRNG {direction=descending}
// params DIRRNG {direction=ascending}
//***********************************************************
// The EXPIPC check can be ignored for concatenation and replication 
// operation depending on whether the parameter value is set to 
// "concat" or "replicate" or "concat:replicate". The default 
// behavior is to report this check on concatenation and replication 
// operation.

//  params EXPIPC {allow_concat_operation="concat:replicate"}
params EXPIPC {allow_concat_operation=""}

//***********************************************************
// ** Parameter to control unlabeled nested blocks   ********
//***********************************************************

// Default check for nested blocks is set to "no".
// This can be changed to "yes" below, if that is preferred. This
// parameter is added to ensure that HAL checks for nested
// blocks which are unlabeled, and issue a warning "NOBLKN" for
// the same.

      params NOBLKN {check_nested_blocks=no}
//    params NOBLKN {check_nested_blocks=yes}

 // By default, the check would be issued for both Verilog and VHDL.
 // When the parameter "language" is set to "verilog", the check
 // would be reported only for Verilog. When the parameter is set
 // to "vhdl" , the check would reported for only VHDL.

   //   params NOBLKN {language=verilog}
   //   params NOBLKN {language=vhdl}
        params NOBLKN {language=both}

//**************************************************************
// ** Parameter to control the behavior of NULCSE **
//**************************************************************

// When the "allow_vhdl_two_state_logic" parameter is set to "yes", 
// the NULCSE rule only considers boolean values of std_logic that is
// '0' and '1'. Alternatively, when the "allow_vhdl_two_state_logic"
// parameter is set to "no", all nine states of std_logic are
// considered. By default, the "allow_vhdl_two_state_logic"
// parameter is set to "no".

      params NULCSE {allow_vhdl_two_state_logic=no}
//    params NULCSE {allow_vhdl_two_state_logic=yes}

// When the "enum_size_as_per_bit" parameter is set to "yes",
// the number of enum value is calculated as the max possible
// values. Alternatively, when "enum_size_as_per_bit" parameter
// is set to "no", it is calculated as the real number of enum
// value. By default, the parameter is set to "no".

      params NULCSE {enum_size_as_per_bit=no}
//    params NULCSE {enum_size_as_per_bit=yes}


//**************************************************************
// ** Parameter to control the behavior of RECTYP **************
//**************************************************************

// When the "allow_record_declaration" parameter is set to "no", 
// HAL will issue RECTYP whenever a record is declared in the
// design. Alternatively, when the "allow_record_declaration" parameter
// is set to "yes", RECTYP will be issues only if the records
// are actually used in the design that is declarations are
// allowed, but references are disallowed. 
// By default this parameter is set to no.

      params RECTYP {allow_record_declaration=yes}
//    params RECTYP {allow_record_declaration=no}

// *************************************************************
// Parameter to control the behavior of size matching rules
// in Verilog
// *************************************************************

// Parameter "unsized_literal" impacts the size calculation of the 
// unsized literals, for example, integers. This will impact the behavior of
// ULCMPE, ULRELE, UELCIT & UELOPR. By default this parameter will
// be set to "size_as_per_type", integer size will be taken as
// 32 bits irrespective of their value. If its value is set to 
// "size_as_per_value" then size will be the number of bits in which 
// integer can be accommodated. For example, size of 3 will be 2 bits.

params HAL {unsized_literal=size_as_per_type}
//params HAL {unsized_literal=size_as_per_value}

// *************************************************************
// ** Parameter to control the behavior of ULRELE/ULCMPE **
// *************************************************************

// The behavior of this check can be controlled by the following parameter
// When an unsized constant is involved in the relational/comparison operation
// and the if the parameter is set to "no", the check will not be reported.
// By default the value of parameter is "yes"

params ULRELE:ULCMPE {warn_unequal_length=yes}

// When comparing with generate var or for loop var and the parameter
// is set to "yes", the size of generate var or for loop var is get from 
// the max value it can take. By default the value of parameter is "no"
params UEASTR:ULRELE:ULCMPE {apply_loop_constraint=no}

//params ULRELE {size_acc_lrm="yes"}
params ULRELE {size_acc_lrm="no"}

// *************************************************************
// ** Parameter to control the behavior of FTNEST **
// *************************************************************

// The following parameter controls the allowable nesting level for FTNEST check
// Tool will only throw warning if function has been nested above the defined limit in this parameter.
// Default value of this parameter is 11, means no nesting check required.
// To enable nesting check, set the below parameter value to < 11.
params FTNEST {allow_nesting_level="11"}


// *************************************************************
// ** Parameter to control the behavior of UELOPR **
// *************************************************************
// The behavior of UELOPR for addition and subtraction operation can
// be controlled with the parameter "ignore_addition" and
//"ignore_subtraction". When the value of the parameter is set to "yes"
// , UELOPR will be ignored for the respective operators. The default
// value of the parameters is "no".

params UELOPR {ignore_addition=no}
params UELOPR {ignore_subtraction=no}

// *************************************************************
// ** Parameter to control the behavior of PADMSB **
// *************************************************************
// The behavior of  for addition and subtraction operation can
// be controlled with the parameter "ignore_addition" and
//"ignore_subtraction". When the value of the parameter is set to "yes"
// PADMSB,  will be ignored for the respective operators. The default
// value of the parameters is "no".

params PADMSB {ignore_addition=no}
params PADMSB {ignore_subtraction=no}

// *************************************************************
// ** Parameter to control the behavior of LENCPI **
// *************************************************************

// If latch enable is controllable by primary inputs through
// some combinational logic, by default HAL does not consider
// it to be controllable and produces LENCPI message. The
// parameter below can be used to change this default behavior. 

params LENCPI {controllable_thru_comb_logic=no} 
// params LENCPI {controllable_thru_comb_logic=yes}

// *************************************************************
// ** Parameter to control the behavior of ADRSND **
// *************************************************************

// If the reset is controllable from top but is not disabled,
// any warning or messages is not reported.
// The given parameter can be used to change this 
// default behavior. 

params ADRSND {controllable_from_top=yes}
//params ADRSND {controllable_from_top=no}

// *************************************************************
// ** Parameter to control the behavior of ASRTSC **
// *************************************************************

// In test mode, if asynchronous set/reset is controllable by 
// primary inputs through some combinational logic, then by 
// default HAL does not consider it to be controllable and 
// produces ASRTSC message. The parameter below can be used 
// to change this default behavior. 

params ASRTSC {controllable_thru_comb_logic=no}
// params ASRTSC {controllable_thru_comb_logic=yes}

// ***********************************************************
// **Parameters to control the behavior of the UNCONN check **
// ***********************************************************

// By default, HAL does not allow the user to leave the output 
// ports of design unconnected when connection is done by 
// name, and generates an  UNCONN warning for the same. The 
// below parameter can be used to change this default behavior. 

params UNCONN {allow_explicitly_unconnected=no}
// params UNCONN {allow_explicitly_unconnected=yes}

//mcj up to here

// ************************************************************
// ** Parameters to control the behavior of the UNCONO check **
// ************************************************************

// By default, HAL does not allow the user to leave the output 
// ports of design unconnected and generates an UNCONO warning
// for the same. The below parameter can be used to change this
// default behavior in case of instances of standard cells
// from a library. If this parameter is set to "no", then
// UNCONO check will not performed for standard cell instances.

params UNCONO {check_on_std_cells=yes}
// params UNCONO {check_on_std_cells=no}

// The following parameter controls the settings for UNCONO rule
// If 'ignore_explicitly_unconnected_port' is set to 'yes', 
// then the tool will not report UNCONO for explicitly 
// unconnected output ports.

params UNCONO {ignore_explicitly_unconnected_port=no}
// params UNCONO {ignore_explicitly_unconnected_port=yes}

// ***********************************************************
// **Parameters to control the behavior of the UNCONI check **
// ***********************************************************

// The following parameter controls the settings for UNCONI rule
// If 'ignore_explicitly_unconnected_port' is set to 'yes', 
// then the tool will not report UNCONI for explicitly 
// unconnected input ports.

params UNCONI {ignore_explicitly_unconnected_port=no}
// params UNCONI {ignore_explicitly_unconnected_port=yes}

// The following parameter controls the settings for UNCONI rule
// If 'ignore_port_with_no_load' is set to 'yes', 
// then the tool will not report UNCONI for unconnected 
// input ports having no load.

params UNCONI {ignore_port_with_no_load=no}
// params UNCONI {ignore_port_with_no_load=yes}

// The following parameter controls the settings for UNCONO rule
// If 'ignore_port_with_no_load' is set to 'yes', 
// then the tool will not report UNCONO for output 
// ports having no load.

params UNCONO {ignore_port_with_no_load=no}
// params UNCONO {ignore_port_with_no_load=yes}

// The following parameter controls the settings for UNCONO rule
// When it set to 'yes', continue line will be displayed for whole
// unconnected bus port.
params UNCONO {show_unconnected_bus_range=no}
// params UNCONO {show_unconnected_bus_range=yes}

// ***********************************************************
// **Parameters to control the behavior of the CBPAHI check **
// ***********************************************************

// The following parameters controls the settings for CBPAHI rule
// If 'report_paths' is set to 'all', then the tool will report
// ALL combinatorial paths, whether they contain a library cell or not
// If 'report_paths' is set to 'nocell' then the tool will report
// only combinatorial paths which do not contain any library cell
// The default behavior is to report all combinational paths,
// including the ones which have library cells.

params CBPAHI {report_paths=all}
// params CBPAHI {report_paths=nocell}

// If 'report_path_till_top_level' is set to 'yes' the tool will
// report the paths upto primary input
// If 'report_path_till_top_level' is set to 'no' the tool will
// report only combinatorial paths upto the point from where
// problem originated.

params CBPAHI {report_path_till_top_level=no}
// params CBPAHI {report_path_till_top_level=yes}

// The parameter 'allowed_hierarchical_depth' is used to define
// the permissible hierarchical depth for which a violation 
// should not be reported.
// When this limit is reached, the tool will report this
// check. By default, this limit is set to '0', which means
// report all violations across hierarchy.
// 
params CBPAHI {allowed_hierarchical_depth=0}
// ***********************************************************
// **  Parameters to control the allowed scan chain length  **
// ***********************************************************

// The following parameter controls the limit for the length of the
// scan chain, which when exceeded, will trigger the SLENEX check in HAL. 
// By default, the scan chain length limit is 200.

params SLENEX {scanlengthlimit=200}
 

// ***********************************************************
// **  Parameters to control the output of -RULES_CHECKED   **
// ***********************************************************

// The following parameters controls the output of -RULES_CHECKED option.
// Following four RULREP parameters in the defines file allow to select
// the kind of rules to be reported by the '-RULES_CHECKED' option:
//  1. Rules successfully checked on the design (no violation)
//     params RULREP {report_successfull=yes|no}
params RULREP {report_successfull=yes}

//  2. Rules violated on the design (one or more violations)
//     params RULREP {report_violated=yes|no}
params RULREP {report_violated=yes}

// Rules not checked on the design
//  3. Deselected or not selected rules from the defines file
//     params RULREP {report_unchecked=yes|no}
params RULREP {report_unchecked=yes}

//  4. Unclassified rules in the definitions file
// params RULREP {report_unclassified=yes|no}
params RULREP {report_unclassified=no}


// ***********************************************************
// **  Parameters to control the behavior of CBYNAM check   **
// ***********************************************************

// The following parameter controls whether the CBYNAM messages should
// be issued for library cells that is
// modules with `celldefine statement in Verilog
// and VITAL design units in VHDL with VITAL_LEVEL0&1 attributes.
// By default, HAL will flag this check for technology cells instantiated
// in the design.

params CBYNAM {check_tech_cells=yes}
// params CBYNAM {check_tech_cells=no}


// ***********************************************************
// **  Parameters to control the behavior of CNSTLT check   **
// ***********************************************************

// The following parameter controls whether the CNSTLT check should be 
// issued for multi-bit Null literals in VHDL and Verilog.
// By default, the multi-bit Null literals are allowed in Verilog design
// but disallowed in a VHDL design.

params CNSTLT {vlog_multibit_null_literal=allow}
// params CNSTLT {vlog_multibit_null_literal=disallow}

params CNSTLT {vhdl_multibit_null_literal=disallow}
// params CNSTLT {vlog_multibit_null_literal=allow}


// ***********************************************************
// **  Parameters to control the behavior of DFDRVS check   **
// ***********************************************************

// The following parameter controls whether the DFDRVS check 
// should be issued or not when some drivers of a signal are 
// flip-flops with set while other drivers are flip-flops with
// reset.

params DFDRVS {ff_latch_set_reset_check=yes}
// params DFDRVS {ff_latch_set_reset_check=no}
 
// The following parameter controls whether the DFDRVS check 
// should be issued or not when some drivers of a signal are 
// flip-flops and others are not, 
// if none of driver is flip-flop then dont throw this.
// Like one driver is latch and other is wire
// default behavior is no, means we will throw this warning if driver is not same

params DFDRVS {enable_if_one_drv_is_ff=no}
//params DFDRVS {enable_if_one_drv_is_ff=yes}

// The following parameter controls whether the DFDRVS check 
// should only be issued if different driver of vector not for array 
// Consider [3:0] a [1:0] , if this parameter is yes,then
// we will throw warning only if a[0][0] is wire and a[0][1] is flip-flop
// if all bits of a[0] are latch and all bits of a[1] are flop
// then we will not throw this warning

params DFDRVS {enable_only_for_packed_not_for_unpacked=no}
//params DFDRVS {enable_only_for_packed_not_for_unpacked=yes}
// ***********************************************************
// **  Parameters to control the behavior of RENAME check   **
// ***********************************************************

// The following parameter controls whether the RENAME check should be
// issued for part-select and bit-select signals in VHDL and Verilog.
// By default, renaming of part select is disallowed.

params RENAME {check_part_select_rename=disallow}
// params RENAME {check_part_select_rename=allow}

// ***********************************************************
// **  Parameters to control the behavior of generated      **
// **  set/resets                                           **
// ***********************************************************

// The following parameter controls whether internally generated
// asynchronous set/resets are to be allowed or not. If this
// parameter is set to "yes", then those asynchronous resets
// will be allowed which are generated by a flip-flop clocked
// by same clock as that of the flip-flop/latch which is being
// reset by that asynchronous control
// params HAL {allow_intern_gen_sync_reset="yes"}
params HAL {allow_intern_gen_sync_reset="no"}

 
// ***********************************************************
// ********  Parameters to control the behavior of  **********
// ********   RDBFAS/REVROP check                    *********
// ***********************************************************

// In Verilog, if a register is assigned using a blocking 
// assignment in an always block then this register will be 
// considered as if it was a "variable" in VHDL process
// There are two checks for this kind of "variable" and these
// are RDBFAS and REVROP. By default, these checks will be enabled.

params HAL {check_verilog_reg_as_vhdl_var=no}
//mcj params HAL {check_verilog_reg_as_vhdl_var=yes}
 
// ***********************************************************
// **  Parameters to control the behavior of INSYNC check   **
// **  The parameters of INSYNC moved to CLKDMN in 13.2     **
// ***********************************************************

 // For flip-flop based synchronizers, by default, all the flip-flops
 // in the synchronizers should trigger at the same edge of the clock.
 // To change this behavior to allow mixed clock edges, set the
 // following parameter 'ff_sync_mixed_clock_edge_ok' to 'yes'
 //
params CLKDMN {ff_sync_mixed_clock_edge_ok="no"}
// params CLKDMN {ff_sync_mixed_clock_edge_ok="yes"}

 // By default, the lockup latches are treated as synchronizers.
 // To turn off this behavior, set the following parameter
 //  'lockup_latch_sync_allowed' to 'no'
 //
params CLKDMN {lockup_latch_sync_allowed="yes"}
// params CLKDMN {lockup_latch_sync_allowed="no"}

 // For flip-flop based synchronizers, if there is a combinatorial
 // logic between the flip-flop of source clock-domain and the
 // first flip-flop of the destination clock-domain synchronizing
 // flip-flops, the default behavior is to allow that combinatorial
 // logic and report the detection of a flip-flop based synchronizer.
 //
 // To change this behavior, to disallow the presence of
 // combinatorial logic, set the following parameter to 'no'
 // If this parameter is set to 'no' and the combinatorial
 // logic is encountered, then clock-domain violation will
 // be reported.
 //
params CLKDMN {ff_sync_combi_logic_ok="yes"}
// params CLKDMN {ff_sync_combi_logic_ok="no"}

// ***********************************************************
// **  Parameter to control the behavior of divided clocks **
// ***********************************************************

params CLKDMN {delayed_clock_as_clock="no"}
// params CLKDMN {delayed_clock_as_clock="yes"}

params CLKDMN {report_bus_on_ff_synchronizer="no"}
//params CLKDMN {report_bus_on_ff_synchronizer="yes"}

// If the following parameter is set to "yes", then all the 
// clock related checks will be done for internally generated 
// clocks as well. By default this parameter is set to "no".

params HAL {internally_generated_clock_as_clock="no"}
// params HAL {internally_generated_clock_as_clock="yes"}



// ***********************************************************
// **  Parameter to control the behavior of unused elements **
// ***********************************************************

 // In the default flow, the structural engine of HAL ignores
 // all the latches/flip-flops/wires which are not driving any
 // logic crossing a module/design-unit boundary. A message
 // INFNOT is issued for each latch/flip-flop/wire which is
 // neither driving any local output nor any actual port of a
 // child instance of module/design-unit. No structural checks
 // are performed on such unused elements.
 // To change this behavior, to consider such unused
 // elements as part of the design and perform checks on them,
 // set the following parameter to 'yes'.

params HAL {preserve_unused_elements=no}
// params HAL {preserve_unused_elements=yes}


// **********************************************************
// **      Parameters for controlling FSM Rule Checks      **
// **********************************************************

 // In an FSM model, the combinational logic describing the next state 
 // calculation is usually represented by a case statement in the HDL.
 // The default clause of the case statement is written for handling error
 // conditions. 
 //
 // As the default behavior of this tool, the default clause of such a case
 // statement is not considered to represent valid states in the FSM
 // and hence transitions described under the default clause are ignored.
 // Hence, states which cannot be reached from any other state apart from 
 // the default clause, are reported as unreachable states.
 //
 // To change this behavior, to consider states reachable from the
 // default clause of case statement representing the next state
 // computation, as reachable states of FSM, set the following parameter
 // ( fsm_states_in_default_clause ) to 'yes'.
params UNRCHS {fsm_states_in_default_clause="no"}
// params UNRCHS {fsm_states_in_default_clause="yes"}


 // When this parameter is set to "yes", combinational logic driven by FSM
 // is considered as FSM output, and not considered as extraneous logic.
 //
 // To change this behavior, and consider all logic except combinational
 // logic driving the next-state of FSM as extraneous logic, set the 
 // following parameter to 'no'. 
params EXTFSM {allow_fsm_output="yes"}
//params EXTFSM {allow_fsm_output="no"}

// ****************************************************
// Parameter to control the asynchronous flip-flop/latch reset
// convention
// *****************************************************

// ASNRST rule is to check whether asynchronous set/reset follows the
// convention set for the parameter 'async_reset_style'. If it does not
// follow then a warning will be issued by HAL. By default 
// 'async_reset_style' is set to 'active_low' that is user will get a
// warning if he uses an 'active_high' set/reset convention.
// Following options can be used to change the behavior
// 1. active_low : Under this option if set/reset is 'active_high' then
// warning will be issued.
// 2. active_high : Under this option if set/reset is 'active_low' then
// warning will be issued.
// 3. either : Under this option rule will be disabled


params ASNRST {async_reset_style="active_low"}
//params ASNRST {async_reset_style="active_high"}
//params ASNRST {async_reset_style="either"}


// ****************************************************
// Parameters to control the synchronous flip-flop/latch reset
// convention
// *****************************************************

// SNCRST rule is to check whether synchronous set/reset follows the
// convention set for the parameter 'sync_reset_style'. If it does not
// follow then a warning will be issued by HAL. By default 
// 'sync_reset_style' is set to 'either' that is this rule will be disabled.
// Following options can be used to change the behavior
// 1. active_low : Under this option if set/reset is 'active_high' then
// warning will be issued.
// 2. active_high : Under this option if set/reset is 'active_low' then
// warning will be issued.
// 3. either : Under this option rule will be disabled.


params SNCRST {sync_reset_style="either"}
//params SNCRST {sync_reset_style="active_low"}
//params SNCRST {sync_reset_style="active_high"} 


// *****************************************************
// Parameter to control DIFRST check on asynchronous and synchronous 
// set/reset signals in HAL
// *****************************************************

// When 'setreset_type' is set to "async_and_sync" (default value) 
// then DIFRST will be issued for both asynchronous and synchronous 
// set/resets. If 'setreset_type' is set to "async_or_sync" then 
// DIFRST will be issued for only asynchronous resets (if present). 
// If no asynchronous reset exits for flip-flop/latch then synchronous 
// resets will be considered. 

params DIFRST {setreset_type="async_and_sync"}
//params DIFRST {setreset_type="async_or_sync"}


// *****************************************************
// Parameter to control SYNASN check in case of asynchronous 
// set/reset signals of flip-flops in HAL
// *****************************************************
// When 'asynchronous_reset_is_synchronous' is set to "yes", flip-flops
// with asynchronous set/reset will be considered as synchronous logic
// while recommending partitioning synchronous and asynchronous logic in
// separate modules. If the value of this parameter is set to "no",
// flip-flops with asynchronous set/reset will be considered as 
// asynchronous logic.

params SYNASN { asynchronous_reset_is_synchronous="yes"}
//params SYNASN { asynchronous_reset_is_synchronous="no"}

// *****************************************************
// Parameter to control the behavior of TXCNOP checks
// *****************************************************

// When 'output_bypass_mode' is set to "strict" (default value) 
// then TXCNOP will be issued if output of tie-x cell 
// is not bypassed using a multiplexer before being used.
// But if this parameter is set to "relax", then if the output of
// tie-x cell is being used through unary operator before
// being bypassed then message will not be issued.

params TXCNOP {output_bypass_mode="strict"}
// params TXCNOP {output_bypass_mode="relax"}


// *****************************************************
// Parameter to control the behavior of MEMNOP checks
// *****************************************************

// When 'output_bypass_mode' is set to "strict" (default value) 
// then MEMNOP will be issued if output of memory
// is not bypassed using a multiplexer before being used.
// But if this parameter is set to "relax", then if the output of
// memory is being used through unary operator before
// being bypassed then message will not be issued.

params MEMNOP {output_bypass_mode="strict"}
// params MEMNOP {output_bypass_mode="relax"}

// ***********************************************************
// Parameter to control the behavior of HAL for unknown rules
// ***********************************************************

// When 'allow_only_hal_and_custom_rules' is set to "yes" 
// HAL will verify that all the rule tags listed in definition
// file are either standard HAL rule/message tags or are
// custom rules registered through "halRegisterRule"
// If it finds any rule which does not meet this criteria,
// it will issue an error and stop processing.
//
// The default value of this parameter is "no" which allows
// non hal and non custom rules, like messages tags from other
// tools like compilers and elaborator, to exist in definition file.

params HAL {allow_only_hal_and_custom_rules="no"}
//params HAL {allow_only_hal_and_custom_rules="yes"}

// When 'divided_clock_domain_same_as_master' is set to "yes" 
// HAL will consider the clock generated from clock divider to
// be of the same domain as that of its master clock which is the
// clock of the clock divider flip-flop. But if this parameter 
// is set to "no" then this will be considered as clock only if it
// is acting as a clock for some latch/flip-flop and domain of 
// this clock is considered to be different than that of it 
// master clock.
// The default value of this parameter is set to "yes".

params HAL {divided_clock_domain_same_as_master="yes"}
//params HAL {divided_clock_domain_same_as_master="no"}


// When 'gated_clock_domain_same_as_master' is set to "yes" 
// HAL will consider the clock generated from clock gating to
// be of the same domain as that of its master clock.
// But if this parameter is set to "no" then this will be 
// considered as clock only if it is acting as a clock for 
// some latch/flip-flop and domain of this clock is considered 
// to be different than that of it master clock.
// The default value of this parameter is set to "no".

params HAL {gated_clock_domain_same_as_master="no"}
//params HAL {gated_clock_domain_same_as_master="yes"}

// When 'gated_reset_domain_same_as_master' is set to "yes"
// HAL will consider the reset generated from reset gating to
// be of the same domain as that of its master reset.
// But if this parameter is set to "no" then this will be
// considered as reset only if it is acting as a reset for
// some latch/flip-flop and domain of this reset is considered
// to be different than that of it master reset.
// The default value of this parameter is set to "no".

params HAL {gated_reset_domain_same_as_master="no"}
//params HAL {gated_reset_domain_same_as_master="yes"}

// The following parameter controls the number of flip-flops to be
// reported with MULTCK/NOTCLK message. This is done to avoid
// performance hit.
// The default limit of this parameter is 10.
params MULTCK {flipflop_reporting_limit=10}

// The following parameter controls the behavior of TIELOG check.
// If this parameter is set to "relax" (default value), then tool
// will report TIELOG message for those outputs which are directly
// connected to constants. But if this parameter is set to "strict"
// then tool will test the outputs through the simple operations 
// like multiplexer, unary operations, concatenation operation and 
// so on. But the tool will not be able to evaluate through complex 
// operations like binary operations.

params TIELOG {output_testing_mode="relax"}
//params TIELOG {output_testing_mode="strict"}

// ***********************************************************
// Parameter to the control the behavior of the check TIELOG
// ***********************************************************
//  params TIELOG {hierarchical="yes"}
    params TIELOG {hierarchical="no"}

// The following parameter controls the behavior of MULNBA check.
// If parameter 'mulnba_reset_mode' is set to "no" (default value), 
// then halsynth will not consider the default non-blocking assignment to 
// a variable as reset and report MULNBA for next non-blocking assignment 
// to the same variable.  If parameter 'mulnba_reset_mode' is set to "yes"
// then default non-blocking assignment will be treated as reset and 
// hence MULNBA will not be issued for the next non-blocking assignment.

//params MULNBA {mulnba_reset_mode="yes"}
params MULNBA {mulnba_reset_mode="no"}

// The following parameter controls the reporting of MULBAS check.
// If the parameter 'mulbas_quick_check' is set to "yes", the exact bits
// that are overwritten through multiple blocking assignments will not be
// reported. If the parameter is set to "no" the bits that are overwritten
// through multiple blocking assignments will be reported. Bitwise analysis
// may be time consuming for large registers.
// The HDL statements indicating multiple blocking assignments will be displayed
// in both cases. 

params MULBAS {mulbas_quick_check="yes"}
// params MULBAS {mulbas_quick_check="no"}

// ***********************************************************
// Parameter to control the behavior of LTCHNM 
// ***********************************************************

// When 'issue_for_ports' is set to "yes", HAL will issue a LTCHNM 
// for ports which are connected to the output of a latch. 
// Alternatively, when set to "no" LTCHNM will not be issued for
// the output of the latch is connected to the module ports.  
//
// The default value of this parameter is "yes" which allows
// LTCHNM to be issued for ports which are connected to the output
// of a latch.

params LTCHNM {issue_for_ports="yes"}
//params LTCHNM {issue_for_ports="no"}

// ***********************************************************
// Parameter to control the behavior of NOINCD 
// ***********************************************************

// If the parameter 'mode' is set to 'strict' then violation will be 
// issued for all the `include directives in the design. However,
// if value of the parameter 'mode' is set to 'relax' then HAL will 
// not report any violation for the included files which does not have
// any module, function, or task definition.

//params NOINCD {mode="strict"}
params NOINCD {mode="relax"}


// ***********************************************************
// Parameter to control the behavior of NETDCL
// ***********************************************************


// To improve design readability and easy identification of implicit nets, it is 
// recommended that all declarations are made prior to non-declarative statements. 
// In addition, it is further recommended that all declarative statements are in the 
// following sequence:
// 1. I/O Declarations
// 2. Internal Signals
// 3. Constants
// You can control the sequence in which declarative statements should appear in a 
// design using the following parameters. 
//   params NETDCL {IO_Decl_Section_Ordering=1}
//   params NETDCL {Internal_Signal_Section_Ordering=2}
//   params NETDCL {Constant_Section_Ordering=3}

// By default, the values of all these parameters is "no_order", which indicates that HAL will 
// not report a violation if the declarations do not follow a sequence. Changing the values 
// of these parameters as suggested above would cause HAL to report a violation if internal 
// signals/constants are declared prior to I/O ports.

// When the value of any of the above parameter is set to "no_order",
// this check will not be performed for that declaration section.
//   params NETDCL {IO_Decl_Section_Ordering=1}
//   params NETDCL {Internal_Signal_Section_Ordering=2}
//   params NETDCL {Constant_Section_Ordering=no_order}
// In the above example,violations will be reported if internal signals are declared
// prior to I/O ports but constants can be inter mixed.
 
params NETDCL {IO_Decl_Section_Ordering=no_order}
params NETDCL {Internal_Signal_Section_Ordering=no_order}
params NETDCL {Constant_Section_Ordering=no_order}


//**************************************************************
// ** Parameter to control the behavior of PRTODR and PRTLYO **
//**************************************************************

// When the layout order is set through the parameter "layout_order"
// the check PRTODR and PRTLYO will ensure that the ports mentioned
// in the port list and port declaration will follow the order 
// specified through the parameter. If the order of both the checks
// do not match then the behavior of the checks PRTODR and PRTLYO
// changes. If the "layout_order" parameter for PRTLYO and PRTODR
// is null then both the checks will not be performed. Alternatively,
// when the "layout_order" parameter for both the checks do 
// match then PRTODR will check that port list matches with
// port declaration. If the order for both the checks are different
// then PRTODR will just check that port declaration maintains
// the layout order.    

//params PRTODR {layout_order="output:inout:input"}
params PRTODR {layout_order=""}
//params PRTODR {layout_order="follow_port_list"}
//params PRTLYO {layout_order="output:inout:input"}
params PRTLYO {layout_order=""}


// ***********************************************************
// Parameter to control the behavior of CDEFNC 
// ***********************************************************

// When the 'case_default_specification' is set to 'strict', 
// then the tool will issue a message CDEFNC if, signals to
// which a value is assigned in the case statement are not
// assigned a value prior to the case statement. Alternatively,
// when set to 'relax', the tool will issue a message CDEFNC,
// if there is no default clause or no pre-assignment of values
// to signals in the incomplete case statement.
//
// The default value of this parameter is 'relax'.

params CDEFNC {case_default_specification="relax"}
//params CDEFNC {case_default_specification="strict"}

// When the 'combinational_block_only' is set to 'yes', 
// then the tool will issue a message CDEFNC ONLY if, the 
// case block appears in a pure combinational block.
// Alternatively, when set to 'no',
// the tool will issue a message CDEFNC,
// for both combinational as well as sequential blocks .
//
// The default value of this parameter is 'no'.

params CDEFNC {combinational_block_only="no"}
//params CDEFNC {combinational_block_only="yes"}

params CDEFNC {full_case_with_no_default_allowed="yes"}
//params CDEFNC {full_case_with_no_default_allowed="no"}

// *****************************************************
// Parameter to control FFWASR and FFASRT checks in case of asynchronous 
// set/reset signals of flip-flops in HAL
// *****************************************************
// The convention for set/reset in the design can be specified using the
// parameter 'convention_for_control_type'. When it is specified as "reset",
// flip-flops are required to have a reset force. When this parameter is
// specified as "set", flip-flops are required to have a set force. When
// this parameter is specified as "mixed", flip-flops are required to have
// either reset or set force. By default this parameter will be set to "mixed"

params HAL { convention_for_control_type="mixed" }
//params HAL { convention_for_control_type="reset" }
//params HAL { convention_for_control_type="set" }

// The style for control forces can be specified using the parameter
// 'convention_for_set_reset_style'.  If this parameter is set to
// "asynchronous", then only asynchronous style for set/reset will be allowed
// in the HDL and hence HAL will report violation for any synchronous
// set/reset. Similarly, if the parameter is set to "synchronous" then HAL
// will report violation for any asynchronous set/reset. If value is set to
// "mixed" then both asynchronous and synchronous style will be allowed for
// set/reset.  Default value of this parameter is "asynchronous".

params HAL { convention_for_set_reset_style="asynchronous" }
//params HAL { convention_for_set_reset_style="synchronous" }
//params HAL { convention_for_set_reset_style="mixed" }

// *******************************************************************
// Parameter to control the FFWASR message, whether HAL reports the
// message with short name or full name for the object.
// The default value of this parameter is short name for the object.
// *******************************************************************
//params FFWASR {print_full_name="yes"}
params FFWASR {print_full_name="no"}

// *******************************************************************
// Parameter to control the FFWNSR message, whether HAL reports the
// message with short name or full name for the object.
// The default value of this parameter is short name for the object.
// *******************************************************************
//params FFWNSR {print_full_name="yes"}
params FFWNSR {print_full_name="no"}

// *****************************************************
// Parameter to control HASPGM and HASLEX checks  
// *****************************************************

// HASPGM is issued for all occurrence of parallel_case, full_case,
// one hot and one cold pragmas. HASLEX is issued for all occurrence
// of synthesis_on/off and translate_on/off pragmas. However their
// behavior can be controlled with the parameter "pragma_control".
// When the parameter "pragma_control" is set to "strict", HASPGM 
// and HASLEX will be issued for all occurrence of pragmas. When 
// it is set to "relax", HASPGM and HASLEX will be ignored for 
// the following conditions:
//-------------------------------------------------------------------------------------------------
//	Directive name		 	 |	RTL description condition for which the 
//					 |	message is ignored
//-------------------------------------------------------------------------------------------------
// 1)  parallel_case                     |	The conditional expression is not duplicated.
// 2) full_case	                 |	All conditions are described. The default clause
//					 |      exists.
// 3)translate_off           		 |      There is no description of logic between
//     translate_on        	         |      translate_off and translate_on.	
//-------------------------------------------------------------------------------------------------

// The default value of the parameter is "strict".
params HAL {pragma_control="strict"}
//params HAL {pragma_control="relax"} 

// ***********************************************************
// Parameters to control the behavior of CONSTC 
// ***********************************************************
// The check for constant condition in value of Verilog parameters is
// controlled through the parameter 'report_parameter'.
// When the value of this parameter is set to 'no', the check is not reported
// for constant conditions in value of Verilog parameters. When the value is
// set to 'yes', the check is reported for constant conditions in value of
// Verilog parameters.
// The default value of this parameter is 'no'.

params CONSTC {report_parameter="no"}
//params CONSTC {report_parameter="yes"}

// The check for constant condition in case statement is controlled through
// the parameter 'ignore_reverse_modeling'.  When the value is set to 'no',
// the check is reported for "case" statements that follow reverse modeling.
// When the value is set to 'yes', the check is not reported for 'case'
// statements that follow reverse modeling.
// The default value of this parameter is 'no'
params CONSTC {ignore_reverse_modeling="no"}
//params CONSTC {ignore_reverse_modeling="yes"}

// The default value of this parameter is 'yes'
//params CONSTC {report_params_in_condition="no"}
params CONSTC {report_params_in_condition="yes"}

// ***********************************************************
// Parameter to control the behavior of CONSTC and  CONSLC
// ***********************************************************
// When the value of parameter 'optimize_condition' is set to 'yes', HAL
// optimizes conditional expressions for CONSTC and CONSLC checks in the
// following cases:
//   * If any operand of the logical "AND" operation is false, the "AND"
//     operation evaluates to false.
//   * If any operand of the logical "OR" operation is true, the "OR"
//     operation evaluates to true.
// When the value of this parameter is set to 'no', these optimizations are not
// attempted.
// The default value of this parameter is 'yes'
params HAL {optimize_condition="yes"}
//params HAL {optimize_condition="no"}

// ***********************************************************
// Parameters to control the behavior of IGNDLY 
// ***********************************************************

// Delays are ignored by synthesis and static verification tools. However,
// specifying a delay in the flip-flop data input can be meaningful in RTL
// simulation. 
// The check for delay specifications can be controlled through the parameters
// 'allow_delay_in_ff_data' and 'allow_delay_in_ff_reset'.
// By default, both these parameters are set to 'no', and IGNDLY is issued on 
// all delays in synthesizable code. 
// If the value of the parameter 'allow_delay_in_ff_data' is specified as 'yes',
// delays are allowed in flip-flop data input, and IGNDLY is issued on all 
// delays except for the delays in flip-flop data input.
// If the value of the parameter 'allow_delay_in_ff_reset' is specified as 'yes', 
// delays are allowed in asynchronous reset/set of the flip-flop, and IGNDLY is
// issued on all other delays.
// If both the parameters are set to "yes", delays are allowed in data,
// as well as asynchronous reset/set of the flip-flop.

params IGNDLY {allow_delay_in_ff_data="no"}
//params IGNDLY {allow_delay_in_ff_data="yes"}
params IGNDLY {allow_delay_in_ff_reset="no"}
//params IGNDLY {allow_delay_in_ff_reset="yes"}

// ***********************************************************
// Parameter to control the behavior of LMTSTS 
// ***********************************************************
// The "max_states" parameter is used to control the number of states 
// in a state machine. By default, the maximum states allowed are 40.
params LMTSTS {max_states=40}

// ***********************************************************
// Parameter to control the behavior of LOOPTM 
// ***********************************************************
// The "max_operation" parameter is used to control the number of 
// times a logic or relational operation between a loop variable 
// and a non-constant value.
// By default, the maximum operation allowed are 10.
params LOOPTM {max_operation=10}

// ***********************************************************
// Parameter to control the behavior of BOUINC 
// ***********************************************************
// Parameter 'lower_bound' is used to specify the value against which
// BOUINC will check the lower bounds of arrays/vectors/ports.
// The default value of the parameter is 0.

   params BOUINC {lower_bound=0}

// ***********************************************************

//***********************************************************
// ** Parameter to control the behavior of EDGMIX ***********
//***********************************************************

// When the "hierarchical" parameter is set to "no", 
// the EDGMIX check will only considers signals using both
// edges in the same module. Alternatively, when the 
// "hierarchical" parameter is set to "yes", this check will
// scan the whole design and ensure that both edges of a clock
// signal is not used in the whole design.
// By default, the "hierarchical" parameter is set to "no".
//    params EDGMIX {hierarchical=yes}
    params EDGMIX {hierarchical=no}

//***********************************************************
// ** Parameter to control the behavior of BADFSM ***********
//***********************************************************
// BADFSM is reported in these 3 scenarios:
// 1. The FSM is coded in one process or always block
// 2. The FSM is coded in more than two processes or always blocks
// 3. The state register or the next state register is a part of any logic
//    apart from the FSM logic
//  This parameter is to control the last(3rd) scenario of BADFSM

    params BADFSM {allow_state_register_use_outside_FSM_logic="yes"}
//    params BADFSM {allow_state_register_use_outside_FSM_logic="no"}


//***************************************************************
//  ** Parameter to control the behavior of FFCSTD **************
//***************************************************************
// Parameter 'output_of_latch' and 'output_of_blackbox' controls the 
// behavior of FFCSTD. When the input to a flip-flop is a latch and
// the parameter 'output_of_latch' is set to 'fixed', FFCSTD will be
// flagged. Similarly if the input to a flip-flop is a blackbox unit
// and the parameter 'output_of_blackbox' is set to 'fixed', FFCSTD 
// will be flagged. The default value of both the parameter is 
// 'variable'.

//  params FFCSTD {output_of_latch=fixed}
  params FFCSTD {output_of_latch=variable}
//  params FFCSTD {output_of_blackbox=fixed}
  params FFCSTD {output_of_blackbox=variable}

//**************************************************************

// Parameter to control logic depth
// ***********************************************************

params LDFFPI {logic_depth_reference=1}
params LDFFPI {logic_depth_threshold=10}
params LDFFPI {logic_depth_inverter=0}
params LDFFPI {logic_depth_and=1}
params LDFFPI {logic_depth_nand=1}
params LDFFPI {logic_depth_or=1}
params LDFFPI {logic_depth_nor=1}
params LDFFPI {logic_depth_xor=1}
params LDFFPI {logic_depth_xnor=1}
params LDFFPI {logic_depth_adder=1}
params LDFFPI {logic_depth_subtract=1}
params LDFFPI {logic_depth_multiply=1}
params LDFFPI {logic_depth_divide=1}
params LDFFPI {logic_depth_mux=1}
params LDFFPI {logic_depth_shift=1}

// ***********************************************************
// Parameter to control the behavior of LOGNEG 
// ***********************************************************

// When the 'mode' is set to 'strict', 
// then the tool will issue a message LOGNEG for all signals
// irrespective of the size of the operand signal
// Alternatively, when set to 'relax', the tool will issue 
// a message LOGNEG, only if the size of the operand signal is greater than 
// 1 bit. 
//
// The default value of this parameter is 'strict'.

params LOGNEG {mode="strict"}
//params LOGNEG {mode="relax"}

// ***********************************************************

// ***********************************************************
// Parameter to control the behavior of LOGAND 
// ***********************************************************

// When the 'mode' is set to 'strict', then the tool will issue a
// message LOGAND for all signals irrespective of the size of the
// operand signal. Alternatively, when set to 'relax', the tool will 
// issue a message LOGAND, only if the size of the operand signal
// is greater than '1' bit. 
//
// The default value of this parameter is 'strict'.

params LOGAND {mode="strict"}
//params LOGAND {mode="relax"}

// ***********************************************************



// ***********************************************************
// Parameter to control the behavior of LOGORP 
// ***********************************************************

// When the 'mode' is set to 'strict', then the tool will issue a
// message LOGORP for all signals irrespective of the size of the
// operand signal. Alternatively, when set to 'relax', the tool will 
// issue a message LOGORP, only if the size of the operand signal
// is greater than '1' bit. 
//
// The default value of this parameter is 'strict'.

params LOGORP {mode="strict"}
//params LOGORP {mode="relax"}

// ***********************************************************


// ***********************************************************
// Parameter to the control the threshold limit for calculating
// the testcoverage of a particular node.
// ***********************************************************
// Parameter for changing the threshold value, which indicates 
// that which node is difficult to traverse, and its analysis
// is not performed by the tool as it is too deep.

params HAL {controllability_observability_threshold=15}

// ***********************************************************
// Parameter to control the behavior of LMULOP 
// ***********************************************************
// Parameter 'multiplication_result_limit' is used to specify
// the value against which LMULOP will check the upper limit on
// the result of multiplication operations used in the design
// The default value of the parameter is 64.

params LMULOP {multiplication_result_limit=64}


// ***********************************************************
// Parameter to control the behavior of LRGOPR 
// ***********************************************************
// The parameter 'max_op_size' is used to specify the maximum size 
// allowed for operands of arithmetic and relational operands.
// A violation is reported if an arithmetic or relational operation
// is performed on operands of a size greater than the specified limit.
// The default value of this parameter is 8.
params LRGOPR {max_op_size=8}

// ***********************************************************
// Parameter to control the behavior of LRGARR 
// ***********************************************************
// The parameter 'array_warning_limit' is used to specify the minimum size 
// of array for which LRGARR will be reported.
params LRGARR {array_warning_limit=10000}

//***********************************************************
// ** Parameter to control the behavior of MXTSBC ***********
//***********************************************************
// The parameter 'max_tri_state_buff_connect_limit' defines the 
// permissible limit to connect a number of tri-state buffers.
// When this limit is set to five(5), the tool will flag a
// message if more than '5' tri-state buffer are connected.
// The default limit is set to 5.

params MXTSBC {max_tri_state_buff_connect_limit=5}

// ***********************************************************
// Parameter to the control the behavior of the check TSBNTH
// ***********************************************************
// Parameter for setting the cells which are to be treated as
// mask cells for the check. If module contains a mask cell
// then the module should only contain mask cells.

//params TSBNTH {mask_cells="and:nand:or:nor:not:xor:xnor:mux:latch:flop"}
params TSBNTH { mask_cells="and:nand:mux" }

// When the parameter 'mask_cell_hierarchical' is set to yes, HAL will
// allow mask cells to be hierarchical, alternatively when set to 'no'
// mask cells will not be allowed to be hierarchical.
//params TSBNTH { mask_cell_hierarchical="no" }
params TSBNTH { mask_cell_hierarchical="yes" }

// *************************************************************
// The following parameter specifies the number of levels to 
// which the "if/if-else" statement can be nested before IFESLV 
// is reported.
// *************************************************************
params IFESLV {nested_level=10}
// params IFESLV {nested_level=10}
 
// *************************************************************
// The following parameter specifies the number of levels to 
// which the "if/if-else" statement can be nested before NESTIF  
// is reported.
// By default, the value of "nested_level" is specified as 10.
// *************************************************************
params NESTIF {nested_level=10} 
// params NESTIF {nested_level=10}

// *************************************************************
// The following parameter specifies the number of levels to 
// which the "if/if-else" statement can be nested before DNSTIF   
// is reported.
// By default, the value of "nested_level" is specified as 10.
// *************************************************************
params DNSTIF {nested_level=10} 
// params DNSTIF {nested_level=10}

// ***************************************************************
// Following parameter are used to to control the behavior of 
// CDWARN check. The check issues with the warning Severity 
// for the Compiler directive which are listed in this 
// parameter. 
// The user can move the compiler directive listed in this list 
// to the list of CDWARN depending upon which compiler 
// directive user wants to issue as a NOTE or as a WARNING.
// ***************************************************************
params CDWARN {compiler_directives_warning="`celldefine:`endcelldefine:`define:`ifdef:`elsif:`else:`ifndef:`undef:`endif"}

// Following parameter are used to control the behavior of 
// CDNOTE check. The check issues with the note Severity 
// for the Compiler directive which are listed in this 
// parameter. 
// The user can move the compiler directive listed in this list 
// to the list of CDNWARN depending upon which compiler 
// directive user wants to issue as a NOTE or as a WARNING.
// ***************************************************************
params CDNOTE {compiler_directives_note="`default_nettype:`include:`line:`nounconnected_drive:`resetall:`timescale:`unconnected_drive"}

// ****************************************************************
// Parameter to control the behavior of IOPNTA
// The default value of this parameter is "all". When the value is
// set to "all", the check is reported for all the "inout" ports
// in the design. When the value of this parameter is set to 
// "top_only", the check applies to "inout" ports of only the 
// top-level module/design unit in the design. When the value of 
// this parameter is set to "sub_only", the check applies to 
// "inout" ports of all modules/design-units other than the 
// top-level module/design-unit in the design.
// ****************************************************************
params IOPNTA {iopnta_control="all"}
//params IOPNTA {iopnta_control="top_only"}
//params IOPNTA {iopnta_control="sub_only"}
//*****************************************************************

//*****************************************************************
//*********************** Parameter for CSTEXP ********************
//*****************************************************************
// The following parameter controls the behavior of CSTEXP when 
// reverse modeling is followed for "case" statements.
// params CSTEXP {ignore_reverse_modeling="no"}
// The default value of this parameter is "no".
// When the value is set to "no", the check is reported for "case"
// statements that follow reverse modeling. 
// When the value is set to "yes", the check is not reported for
// "case" statements that follow reverse modeling.
// ****************************************************************
     params CSTEXP {ignore_reverse_modeling="no"}
//   params CSTEXP {ignore_reverse_modeling="yes"}

// The following parameter controls the behavior of CSTEXP.
// By default, CSTEXP is reported if the expressions of the 
// "case" items include operators other than "concatenation",
// "replicate","add","subtract","multiply","divide","modulus" operators.
// You can add to, or remove operators from this list.
//   params CSTEXP {ignore_operator= "concat:replicate"}
     params CSTEXP {ignore_operator="concat:replicate:add:subtract:multiply:divide:modulus"} 

// The following parameter controls the behavior of CSTEXP in case of unary operators.
// The type of unary operator set in the parameter will be ignored and CSTEXP will not
// be reported. By default the value of parameter is "none" and CSTEXP is reported for 
// all unary operators. If the value of parameter "ignore_unary_operator" is set to "all",
// then all the unary operators are ignored. 
    params CSTEXP {ignore_unary_operator="none"}
//  params CSTEXP {ignore_unary_operator="all"}
//  params CSTEXP {ignore_unary_operator="plus:minus:not:and:nand:or:nor:xor:xnor:bitneg"}

// **************************************************************
// The following parameter controls the behavior of CSTLOA.
// params CSTLOA {ignore_operator= "concat:replicate:add:subtract:multiply:divide:modulus"}
// By default, CSTLOA is reported for all expressions used as 
// case selectors except for expressions that use "concatenation"
// "replication","add","subtract","multiply","divide","modulus" operators.
// You can add to, or remove operators from this list.
// **************************************************************
params CSTLOA {ignore_operator="concat:replicate:add:subtract:multiply:divide:modulus"}

// **************************************************************************
// The following parameter specifies the recommended data types 
// for the loop variable of the "for" loop.
// params LOPIDX {allow_loopvar="integer:int:shortint:longint:reg:reg_signed"}
// The recommended data types for the loop variable are integer, 
// int,shortint,longint, reg and signed reg.
// ***************************************************************************
params LOPIDX {allow_loopvar="integer:int:shortint:longint:reg:reg_signed"}

// ************************************************************************
// This parameter controls the behavior of CSTBWD,CSWDXZ when the binary
// number system is used to define constants. The default value of this
// parameter is "5", which indicates that the check is reported for
// constants of five bits or more. 
// By default, the value of "bit_width_allowed_bin_system" is specified as 5.
// *************************************************************************
params CSTBWD:CSWDXZ {bit_width_allowed_bin_system=5}

// ************************************************************************
// This parameter controls the behavior of CSTBWD,CSWDXZ when number system
// other than binary is used to define constants. The default value of this
// parameter is "5", which indicates that the check is reported for
// constants of five digits or more (defined using number system other than
// binary). 
// By default, the value of "bit_width_allowed_other_system" is specified as 5.
// *************************************************************************
params CSTBWD:CSWDXZ {bit_width_allowed_other_system=5}

// ***********************************************************
// The following parameter specifies the minimum  parameter value
// for which CONSBS will not be reported.
// By default, the value of "min_value_allowed_for_parameter" is
// specified as 9. 
// ***********************************************************
params CONSBS {min_value_allowed_for_parameters=7}

// ***********************************************************
// Parameter to the control the behavior of the check BVDDAB
// ***********************************************************
// The behavior of BVDDAB is controlled by the parameter 'output_port_only'.
// When the value of this parameter is set to 'yes', this check is performed
// only on output ports. When the value of this parameter is set to 'no', this
// check is performed on all variables, including the output ports.
// The default value of this parameter is 'yes'.
params BVDDAB {output_port_only="yes"}
//params BVDDAB {output_port_only="no"}


// ***********************************************************
// Parameter to the control the behavior of the check EXLTRS
// ***********************************************************
// The behavior of EXLTRS is controlled by the parameter 'check_hierarchy'.
// When the value of this parameter is set to 'no', HAL checks if an expression
// drives the condition logic of a tristate buffer in the module the buffer
// is used in. When the value of this parameter is set to 'yes', expression
// drivers in the parent hierarchy are checked.
// The default value of this parameter is 'no'.
params EXLTRS {check_hierarchy="no"}
//params EXLTRS {check_hierarchy="yes"}

//***********************************************************
// ** Parameter to control the behavior of MXFNOT ***********
//***********************************************************
// The parameter 'max_fanout_limit' defines the permissible limit
// of fanout of a port.
// A violation is reported if the fanout of a port exceeds the limit specified
// by this parameter.
// The default limit of this parameter is set to 10.

params MXFNOT {max_fanout_limit=10}

//***********************************************************
// ** Parameter to control the behavior of SLNOTP ***********
//***********************************************************
// If the enable of a tristate buffer is controllable by primary inputs
// through some combinational logic, HAL does not consider it to be
// controllable. However, you can use the following parameter to change
// this default behavior, and consider the enable of a tristate buffer
// driven through combinational logic as controllable if any net in the
// combinational logic is controlled by a primary input.

params SLNOTP {controllable_thru_comb_logic=no} 
// params SLNOTP {controllable_thru_comb_logic=yes}

//***********************************************************

// **************************************************************
// Parameter to the control the behavior of the check 
// STYSUL,STYSUV,STYBIT,STYBTV,PRTTYP
// ************************************************************** 
// When the 'top_only' is set to 'yes', 
// then the tool will check for STYSUL,STYSUV,STYBIT,STYBTV,PRTTYP only 
// for TOP level modules
// the top being the either the TOP module used for elaboration or the 
// top module(s) specified using HAL option '-INST_TOP'. Alternatively,
// when set to 'no', the tool will check for STYSUL,STYSUV,STYBIT,STYBTV,
// PRTTYP for all the modules.
//
// The default value of this parameter is 'no'.

params STYSUL:STYSUV:STYBIT:STYBTV:PRTTYP {top_only=no}
//params STYSUL:STYSUV:STYBIT:STYBTV:PRTTYP {top_only=yes}


//**************************************************************
// ** Parameter to control the behavior of the check ESCNTA  ***
//**************************************************************
// When the "checks_on_netlist" parameter is set to "yes", 
// the ESCNTA rule will checked on 'netlist' also. Alternatively, 
// when the "checks_on_netlist" parameter is set to "no", this rule
// is checked only on RTL. By default, the "checks_on_netlist" 
//parameter is set to "no".

params ESCNTA {checks_on_netlist=no}
//params ESCNTA {checks_on_netlist=yes}


// ***********************************************************
// Parameter to the control the behavior of the check ATLGLC
// ***********************************************************
// To ignore this check for simple assignment statements,
// set the value of the following parameter to "yes". 
//params ATLGLC {ignore_simple_asgnt_stmt=yes}
params ATLGLC {ignore_simple_asgnt_stmt=no}


// ***********************************************************
// Parameter to the control the behavior of the check RSTGNH
// ***********************************************************
//params RSTGNH {set_reset_generation_top_level="yes"}
params RSTGNH {set_reset_generation_top_level="no"}

// ***********************************************************
// Disable FFNMOD by default
// ***********************************************************
// By default, FFNMOD check is disabled, to enable this check 
// change the value of below parameter to on.

//params FFNMOD {on}
params FFNMOD {off}

// ***************************************************************
// ** Parameter to the control the behavior of the check GTCLKN/GTDCLK **
// ***************************************************************
// By default, gated clocks are considered problematic, and the check GTDCLK
// is reported on gated clocks. However, if you want to allow certain types
// of gates for clock generation, you can specify those through the parameter
// "flag_only" associated with the check GTCLKN. For the gates specified by
//  this parameter, GTDCLK will not be reported, and GTCLKN will be reported
// instead. The gates that can be allowed through this parameter are:
// params GTCLKN {flag_only="and:nand:or:nor:xor:xnor:mux:tri"}
// By default, no value is specified for this parameter and therefore,
// GTDCLK is reported for all kinds of gated clocks.

// ***************************************************************
// ** Parameter to the control the behavior of the check GTCLKN/GTDCLK **
// ***************************************************************
// By default, HAL would check gated clock only for flip-flop, you can check 
// the gated clock of latch through the parameter the parameter 
// "check_latch_clock".

params GTDCLK {check_latch_clock="no"}

// By default, the parameter is set to "no", If the parameter is set to "yes", 
// GTDCLK will be reported for gated clock of latch.

params GTDCLK {identify_clock_gating_cell="no"}
// By default, clock gating cell is treated as a gated clocks and the check 
// GTDCLK is reported. When the value of this parameter is set to "yes",
// clock gating cells are differentiated from gated clock and the check 
// GTDCLK is not reported.

// ***************************************************************
// ** Parameter to the control the behavior of the HAL clock checks in case of clock gate**
// ***************************************************************
params HAL {clock_check_behind_clock_gate="no"}
// By default, clock gating cell is treated as a gated clocks and the check 
// GTDCLK is reported. When the value of this parameter is set to "yes",
// clock gating cells are identified and any clock controllability check will 
// be performed on clock that is input to clock gating cell.

// ***************************************************************
// ** Parameter to the control the behavior of the check LGRSTL/GLTASR **
// ***************************************************************
// By default, gated resets are considered problematic, and the check GLTASR
// is reported on gated resets. However, if you want to allow certain types
// of gates for reset generation, you can specify those through the parameter
// "flag_only" associated with the check LGRSTL. For the gates specified by
//  this parameter, GLTASR will not be reported, and LGRSTL will be reported
// instead. The gates that can be allowed through this parameter are:
// params LGRSTL {flag_only="and:nand:or:nor:xor:xnor:mux:tri"}
// By default, no value is specified for this parameter and therefore,
// GLTASR is reported for all kinds of gated resets.

// ***************************************************************
// ***************************************************************
// ** Parameter to the control the behavior of the check GLTASR **
// ***************************************************************
// By default, the rule GLTASR treats multi-driven signals as
// combinational logic and flags the rule. This behavior can be
// changed by the parameter 
// 'treat_multi_driven_as_combinational_logic' 
// When the parameter 'treat_multi_driven_as_combinational_logic' is
// "yes" HAL will treat all multi-driven signals as combinational 
// logic. Alternatively, when the parameter is set to 'no', 
// HAL will trace the multi-driven signals and check if a combinational
// logic is driving the reset. If a combinational logic is found
// the rule GLTASR will be flagged.
// The default value of this parameter is set to "yes".
 params GLTASR {treat_multi_driven_as_combinational_logic="yes"}
 //params GLTASR {treat_multi_driven_as_combinational_logic="no"}

// By default, the set/reset name will not be printed in the short
// message, set/reset logic created through instantiating same module
// will be reported only once. To report GLTASR for each set/reset
// logic, set this parameter to "yes". The default value of this
// parameter is set to "no".
//params GLTASR {print_name="yes"}
params GLTASR {print_name="no"}

// *******************************************************************
//  Parameter to control the behavior of check MRSTDT
// *******************************************************************
// The behavior of the check MRSTDT is controlled by the parameter 
// 'same_reset_line'.
// When the value of the parameter is set to 'no', MRSTDT reports the usage
// of asynchronous and synchronous resets/sets in the entire design. When
// the value of this parameter is set to 'yes', MRSTDT reports the usage
// of asynchronous and synchronous resets/sets for the same reset only.
// The default value of this parameter is set to 'no'.
params MRSTDT {same_reset_line="no"}
//params MRSTDT {same_reset_line="yes"}

// *******************************************************************
//  Parameter to control the suppression of duplicate custom messages 
// *******************************************************************
// params HAL {allow_duplicate_custom_messages="yes"}
params HAL {allow_duplicate_custom_messages="no"}

// ***************************************************************
// ** Parameter to the control the behavior of the check LTASRT **
// ***************************************************************
// params LTASRT {convention_for_set_reset_style="asynchronous"| "synchronous"| "mixed"}
// The default value of this parameter is "asynchronous".
// When the parameter is set to "asynchronous", only "asynchronous" 
// style is allowed for set/reset of a latch.
// When the parameter is set to "synchronous", only "synchronous" 
// style is allowed for set/reset of a latch.
// When the parameter is set to "mixed", a mix of "asynchronous" 
// and "synchronous" styles are allowed for set/reset of a latch.

params LTASRT { convention_for_set_reset_style="asynchronous" }
//params LTASRT { convention_for_set_reset_style="synchronous" }
//params LTASRT { convention_for_set_reset_style="mixed" }

// ***************************************************************
// ** Parameter to the control the behavior of the check LTASRT **
// ***************************************************************
// params LTASRT {convention_for_control_type="mixed"| "reset"| "set"}
// The default value of this parameter is "mixed".
// When the parameter is set to "mixed", latches can have 
// both "set" and "reset" signals.
// When the parameter is set to "reset", latches can have 
// only "reset" signals.
// When the parameter is set to "set", latches can have 
// only "set" signals. 

params LTASRT { convention_for_control_type="mixed" }
//params LTASRT { convention_for_control_type="reset" }
//params LTASRT { convention_for_control_type="set" }

// ***************************************************************
// ** Parameter to the control the behavior of the check MLTDRV **
// ***************************************************************
// By default, the rule MLTDRV will be flagged if a signal
// has more than one driver and none of the multiple drivers are
// driven by 'Z'. This rule does not consider the 'Z' driver
// as a valid driver and will ignore that driver. This behavior can be
// changed by the parameter 'ignore_z_drivers' 
// When the parameter 'ignore_z_drivers' is set to "no", and if a 
// signal has two drivers. And one of the drivers is 'Z', then the
// tool will consider the 'Z' driver as a valid driver and the check
// will be reported.
// Alternatively, when the parameter is set to 'yes', the tool will 
// allow the signal to have a 'Z' driver and not flag the check.

// The default value of this parameter is set to "yes".
 params MLTDRV {ignore_z_drivers="yes"}
 //params MLTDRV {ignore_z_drivers="no"}

// ***************************************************************
// ** Parameter to the control the behavior of the check MLTDIO **
// ***************************************************************
// This check is same as MLTDRV except it is reported for inout
// port only.By default the rule MLTDIO will be flagged off.If 
// param 'multiply_driven_inout_port_separate_reporting' is set
// to 'yes' and an inout port has more than one drivers then MLTDIO
// will be reported.

// The default value of this parameter is set to "no".
// params MLTDIO {multiply_driven_inout_port_separate_reporting="yes"}
   params MLTDIO {multiply_driven_inout_port_separate_reporting="no"}

// ***************************************************************
// ** Parameter to the control the behavior of the check SEQCOM **
// ***************************************************************
// This is to check whether sequential and combinational logic
// are in separate block or not
// By default this parameter is set to no.
// params HAL {separate_comb_seq_logic="yes"}
   params HAL {separate_comb_seq_logic="no"}


// ***************************************************************
// ** Parameter to the control the behavior of the check SUTHRU **
// ***************************************************************
params SUTHRU {enable_shoot_through_refinement="no"}
//params SUTHRU {enable_shoot_through_refinement="yes"}

// ***************************************************************
// ** Parameter to the control the behavior of the check REGRNM **
// ***************************************************************
//params REGRNM {synthesized_registers_only="yes"}
params REGRNM {synthesized_registers_only="no"}

// ***********************************************************
// Parameter to the control the behavior of the check RSTGNH
// ***********************************************************
//params RSTGNH {set_reset_generation_top_level="yes"}
params RSTGNH {set_reset_generation_top_level="no"}


// ***********************************************************
// Parameter to the control the behavior of the check ASNCLD
// ***********************************************************
// params ASNCLD {hierarchical="yes"}
   params ASNCLD {hierarchical="no"}

// ***********************************************************
// Parameter to the control the behavior of the check SYNPRT
// ***********************************************************
// params SYNPRT {physical_block_only="no"| "yes"}
// The default value of this parameter is "no" and in 
// this case, SYNPRT is reported for all blocks.
// When the parameter 'physical_block_only' is set to "yes", 
// SYNPRT is reported only for physical blocks.
// params SYNPRT {physical_block_only="yes"}
   params SYNPRT {physical_block_only="no"}

// When 'register_output_ports' is set to "strict" 
// then SYNPRT will be issued if the output port
// is not registered before connected to an instance.
// But if this parameter is set to "relax", then if the 
// output port is registered inside an instance, then 
// the check will not be flagged. This parameter defines
// whether to treat an instance as a logic or not.
//params SYNPRT {register_output_ports="strict"}
params SYNPRT {register_output_ports="relax"}

//*************************************************************/
//* Parameters to control the interpretation of cell/blackbox */
//****         in clock-line and reset-line                ****/

params HAL {cell_as_inverter_in_clock_reset_line=no}
//params HAL {cell_as_inverter_in_clock_reset_line=yes}

params HAL {trace_blackbox_in_clock_reset_line=no}
//params HAL {trace_blackbox_in_clock_reset_line=yes}

***************************************************************


// ***************************************************************
// **   Parameter to the control the behavior of the check CLKUCL
// ***************************************************************
//
// The rule CLKUCL, checks that the master clock, detected from 
// the clock generation point, is not used as an input to any combinational
// logic. By default, the check will be reported when the tool encounters the
// first combinational logic where it is used. However, this behavior can be
// parameterized to define the total number of gates allowed in the clock 
// line, using the following parameter 
// 
  params CLKUCL {clock_logic_depth_threshold=0}
//
// The default value of this parameter is set to '0'.

// The depth of different types of logic gates is specified using the 
// parameters associated with the check LDFFPI.
//
// The tool adds the depths of the logic gates encountered, till it 
// reaches a sequential logic, a hanging signal or a primary output. If the 
// depth exceeds the specified threshold limit, the check is reported.
//
// To allow any logic gate in the clock line, we can define the weight 
// specified for the logic gate as '0'. This logic gate does not contribute 
// to the logic depth of the clock line. 
//
// ***************************************************************

// ***************************************************************
// **   Parameter to the control the behavior of the check RSTUCL
// ***************************************************************

// The rule RSTUCL, checks that the master reset(set/reset), detected from 
// the reset generation point, is not used as an input to any combinational
// logic. By default, the check will be reported when the tool encounters the
// first combinational logic where it is used. However, this behavior can be 
// parameterized to define the total number of gates allowed in the reset 
// line, using the following parameter 
// 
  params RSTUCL {reset_logic_depth_threshold=0}
//
// The default value of this parameter is set to '0'.

// The depth of different types of logic gates is specified using the 
// parameters associated with the check LDFFPI.
//
// The tool adds the depths of the logic gates encountered, till it 
// reaches a sequential logic, a hanging signal or a primary output. If the 
// depth exceeds the specified threshold limit, the check is reported.
//
// To allow any logic gate in the reset line, we can define the weight 
// specified for the logic gate as '0'. This logic gate does not contribute 
// to the logic depth of the reset line. 
// 
// ***************************************************************

// *******************************************************
// ************Parameter for TRUNCC **********************
// *******************************************************
// This parameter controls the behavior of TRUNCC checking for signed value. 
// The default value is no. If set to yes , TRUNCC will be reported for 
// signed value which has a width larger than the expected operand width.

params TRUNCC {truncate_sign_bit="no"}
//params TRUNCC {truncate_sign_bit="yes"}


// *******************************************************
// ************Parameter for URDWIR **********************
// *******************************************************
// This parameter controls the behavior of URDWIR. It specifies the pattern
// of the signal name on which URDWIR should not be flagged. By default the
// check is applied to all signals.

//params URDWIR {pattern="nc_*" local_regex_style="csh"}
//params URDWIR {pattern="nc_.*$|^.*_nc" local_regex_style="full"}


// *******************************************************************
//  Parameter to control the behavior of passing no warning EXTPRG to
//  compiler to suppress this warning
// *******************************************************************
//params HAL {allow_comment_after_lintpragma="yes"}
params HAL {allow_comment_after_lintpragma="no"}

// *******************************************************************
//  Parameter to control the behavior of reporting note UPCSFN
// *******************************************************************
params UPCSFN {report_uppercase_in_filename="no"}
//params UPCSFN {report_uppercase_in_filename="yes"}

// *******************************************************************
//  Parameter to control the behavior for partial unused vector,
//  if set to no, partially unused vector will be ignored.
// *******************************************************************
params HAL {report_partially_unused_vector="yes"}
//params HAL {report_partially_unused_vector="no"}

// *******************************************************************
//  Parameter to control the behavior for TIMSPD,
//  if set to yes, TIMSPD is reported only for time variables used in 
//  wait for statement,If set to no, all the defined time variables 
//  are reported.
// *******************************************************************
//params TIMSPD {report_wait_argument_only="no"}
params TIMSPD {report_wait_argument_only="yes"}

// *******************************************************************
//  Parameter to control the behavior for INTCON,
//  if set to yes, constrained integer type signal present in switchable
//  power domain will also be reported.
// *******************************************************************
params INTCON {report_constrained_int="no"}
//params INTCON {report_constrained_int="yes"}

// *******************************************************************
//  Parameter to control the behavior for INTCON,
//  if set to yes, generic declared as type integer present in switchable
//  power domain will be reported.
// *******************************************************************
params INTCON {report_generic="no"}
//params INTCON {report_generic="yes"}

// *******************************************************************
//  Parameter to control the behavior for INTCON,
//  if set to yes, INTCON will be reported only on integer used as/in
//  index of array.
// *******************************************************************
params INTCON {report_indexed="no"}
//params INTCON {report_indexed="yes"}

// *******************************************************************
//  Parameter to control the behavior for INTCON:RELSPD,
//  if set to yes, INTCON:RELSPD will be reported on variables.
// *******************************************************************
params INTCON:RELSPD {report_variable="no"}
//params INTCON:RELSPD {report_variable="yes"}

// *******************************************************************
//  Parameter to control the behavior for CLKMBT,
//  if set to yes, CLKMBT will be reported on bus clock signal
// *******************************************************************
params CLKMBT {clock_using_bus_signal="no"}
//params CLKMBT {clock_using_bus_signal="yes"}

// *******************************************************************
//  Parameter to control the behavior for usage rules, URAWIR/URAREG ...
//  when signal connected to unresolved instance. if set to yes, this
//  signal is considered as driven by the unresolved instance
// *******************************************************************
params HAL {check_connection_to_unresolved_instance="no"}
//params HAL {check_connection_to_unresolved_instance="yes"}

// *******************************************************************
//  Parameter to control the maximum size of case selector, the default
//  value is 20. Parameter value less than 20 will be ignored. But if 
//  specified with large value, there could be performance issue.
//params HAL {max_case_size=20}

// *******************************************************************
//  Parameter to control the rule CTLCHR to support the "DOS style" linefeed
//  and carriage return.
// *******************************************************************
params CTLCHR {support_dos_style="no"}
//params CTLCHR {support_dos_style="yes"}

// *******************************************************************
//  Parameter to control whether the rule IMPNET need to report on single
//  bit nets implicitly declaration, the default value is yes.
// *******************************************************************
params IMPNET {report_single_bit="yes"}
// params IMPNET {report_single_bit="no"}

// *******************************************************************
//  Parameter to control whether the rule SYNTXZ need to report on 'x', 'z'
//  or both.
// *******************************************************************
params SYNTXZ {report_value_type="both"}
//params SYNTXZ {report_value_type="x"}
//params SYNTXZ {report_value_type="z"}

// *******************************************************************
//  Parameter to control the behavior of RSTDMN/RSTDAS/RSTSCB/RSTSYN,
//  If set to "no", for same target flop, only first pair is searched.
// *******************************************************************
params HAL {find_all_fanin_reset="no"}
//params HAL {find_all_fanin_reset="yes"}

// *******************************************************************
//  Make reset domain crossing checks off by default
// *******************************************************************
params RSTDAS:RSTDMN:RSTSCB:RSTSYN {off}

//**************************************************************
//    Parameters for LARGEN
//**************************************************************
// parameter 'generate_loop_threshold' set the threshold of generate for
// loop, when exceeded, LARGEN is reported.
// The default value of this parameter is 64, you can change to any value
// more than 1.
params LARGEN {generate_loop_threshold=64}

// parameter 'generate_nesting_threshold' set the threshold of generate
// nesting level, when exceeded, LARGEN is reported.
// The default value of this parameter is 3, you can change to any value
// more than 1.
params LARGEN {generate_nesting_threshold=3}

//**************************************************************
// Parameters for LARFOR
//**************************************************************
// parameter 'for_loop_threshold' set the threshold of for-loop, when
// exceeded, LARFOR is reported.
// The default value of this parameter is 1024, you can change to any value
// more than 1.
params LARFOR {for_loop_threshold=1024}

// parameter 'for_nesting_threshold' set the threshold of for-loop
// nesting level, when exceeded, LARFOR is reported.
// The default value of this parameter is 3, you can change to any value
// more than 1.
params LARFOR {for_nesting_threshold=3}

//**************************************************************
// Parameters for LARMEM
//**************************************************************
// parameter 'memory_size_threshold' set the threshold of memory, when
// exceeded, LARMEM is reported.
// The default value of this parameter is 16384, you can change to any value
// more than 256.
params LARMEM {memory_size_threshold=16384}

//**************************************************************
// Parameters for LNSENS
//**************************************************************
// parameter 'list_size_threshold' set the threshold of sensitivity list
// of process block, when exceeded, LNSENS is reported.
// The default value of this parameter is 64, you can change to any value
// more than 1.
params LNSENS {list_size_threshold=64}

// *******************************************************************
// Parameter to control the behavior of CMBPAU, whether HAL reports loop
// with simple assignment.
// *******************************************************************
//params CMBPAU {report_simple_assignment="yes"}
params CMBPAU {report_simple_assignment="no"}

// *******************************************************************
// Parameter to control the LATINF message, whether HAL reports the
// message with short name or full name for the object.
// The default value of this parameter is short name for the object.
// *******************************************************************
//params LATINF {print_full_name="yes"}
params LATINF {print_full_name="no"}

// *******************************************************************
// Parameter to control schematic of MEMNCB  message, whether HAL display
// all the paths of input of memory cell or defined one.
// By default tool will show schematic of all inputs of memory element defined in design_info.
// *******************************************************************
//params MEMNCB {show_in_schematic="write_clock:write_enable:chip_select:all"}
params MEMNCB {show_in_schematic="all"}

// **************************************************************
// *********** Parameter for controlling RWRACE *****************
// **************************************************************
// This parameter controls the behavior of RWRACE. If the parameter
// is set to "yes", RWRACE will be reported for combinational logic as well
// if it is set to "no", race warning will not be throw for combinational logic
// default value is "no"

params RWRACE {enable_check_on_combinational_logic="no"}
//params RWRACE {enable_check_on_combinational_logic="yes"}
